<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hi Guys</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<center>
<font size=6>Welcome to My Blog! </font>
</center>
<hr />
<a id="more"></a>
<p><img src="http://qd79xrb7g.bkt.clouddn.com/jiulongtu.JPG" /></p>
<center>
《九龍圖》
<center>
<center>
我最愛的畫作
<center>
]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title>Analysis of single-cell ATAC-seq data using SnapATAC software (2)：10x Adult Mouse Brain</title>
    <url>/posts/34331839/</url>
    <content><![CDATA[<h1 id="introduction">Introduction</h1>
<hr />
<div class="note info no-icon"><h2 id="x-adult-mouse-brain">10X Adult Mouse Brain</h2>
<p>In this example, we will be analyzing a dataset of 5K cells from the adult mouse brain available from 10X genomics. All the data used in this analysis can be downloaded from <span class="exturl" data-url="aHR0cDovL3JlbmxhYi5zZHNjLmVkdS9yM2Zhbmcvc2hhcmUvZ2l0aHViL01vdXNlX0JyYWluXzEwWC8=">here<i class="fa fa-external-link-alt"></i></span>.</p>
</div>
<p><br></p>
<a id="more"></a>
<h1 id="analysis-content">Analysis content</h1>
<hr />
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#10x-adult-mouse-brain">10X Adult Mouse Brain</a></li>
</ul></li>
<li><a href="#analysis-content">Analysis content</a>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#step-0-data-download"><a name="data_download"></a><strong>Step 0. Data download</strong></a></li>
<li><a href="#step-1-barcode-selection"><a name="barcode_selection"></a><strong>Step 1. Barcode selection</strong></a></li>
<li><a href="#step-2-add-cell-by-bin-matrix"><a name="add_bmat"></a><strong>Step 2. Add cell-by-bin matrix</strong></a></li>
<li><a href="#step-3-matrix-binarization"><a name="make_binary"></a><strong>Step 3. Matrix binarization</strong></a></li>
<li><a href="#step-4-bin-filtering"><a name="bin_filter"></a><strong>Step 4. Bin filtering</strong></a></li>
<li><a href="#step-5-dimensionality-reduction"><a name="diffusion_maps"></a><strong>Step 5. Dimensionality reduction</strong></a></li>
<li><a href="#step-6-determine-significant-components"><a name="pc_select"></a><strong>Step 6. Determine significant components</strong></a></li>
<li><a href="#step-7-graph-based-clustering"><a name="cluster"></a><strong>Step 7. Graph-based clustering</strong></a></li>
<li><a href="#step-8-visualization"><a name="viz"></a><strong>Step 8. Visualization</strong></a></li>
<li><a href="#step-9-gene-based-annotation"><a name="gene_tsne"></a><strong>Step 9. Gene based annotation</strong></a></li>
<li><a href="#step-10-heretical-clustering"><a name="heretical_clustering"></a><strong>Step 10. Heretical clustering</strong></a></li>
<li><a href="#step-11-identify-peaks"><a name="peak_call"></a><strong>Step 11. Identify peaks</strong></a></li>
<li><a href="#step-12-create-a-cell-by-peak-matrix"><a name="create_pmat"></a><strong>Step 12. Create a cell-by-peak matrix</strong></a></li>
<li><a href="#step-13-add-cell-by-peak-matrix"><a name="add_pmat"></a><strong>Step 13. Add cell-by-peak matrix</strong></a></li>
<li><a href="#step-14-identify-differentially-accessible-regions"><a name="diff_analysis"></a><strong>Step 14. Identify differentially accessible regions</strong></a></li>
<li><a href="#step-15-motif-analysis-identifies-master-regulators"><a name="homer_chromVAR"></a><strong>Step 15. Motif analysis identifies master regulators</strong></a></li>
<li><a href="#step-16-great-analysis"><a name="great_analysis"></a><strong>Step 16. GREAT analysis</strong></a></li>
</ul></li>
</ul>
<h2 id="step-0.-data-download"><a name="data_download"></a><strong>Step 0. Data download</strong></h2>
<p>In this example, we will skip the snap generation (See <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3IzZmFuZy9TbmFwQVRBQy9ibG9iL21hc3Rlci9leGFtcGxlcy8xMFhfUEJNQ18xNUsvUkVBRE1FLm1k">here<i class="fa fa-external-link-alt"></i></span> for how to generate a snap file). Instead, we will download the snap file. The downloaded snap file already contains the cell-by-bin/cell-by-peak matrix.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://renlab.sdsc.edu/r3fang/share/github/Mouse_Brain_10X/atac_v1_adult_brain_fresh_5k.snap</span><br><span class="line">$ http://renlab.sdsc.edu/r3fang/share/github/Mouse_Brain_10X/atac_v1_adult_brain_fresh_5k_singlecell.csv</span><br></pre></td></tr></table></figure>
<h2 id="step-1.-barcode-selection"><a name="barcode_selection"></a><strong>Step 1. Barcode selection</strong></h2>
<p>We select high-quality barcodes based on two criteria:<br> 1) number of unique fragments;<br> 2) fragments in promoter ratio;</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(SnapATAC);</span><br><span class="line">&gt; x.sp = createSnap(</span><br><span class="line">    file=<span class="string">"atac_v1_adult_brain_fresh_5k.snap"</span>,</span><br><span class="line">    sample=<span class="string">"atac_v1_adult_brain_fresh_5k"</span>,</span><br><span class="line">    num.cores=<span class="number">1</span></span><br><span class="line">  );</span><br><span class="line">&gt; barcodes = read.csv(</span><br><span class="line">    <span class="string">"atac_v1_adult_brain_fresh_5k_singlecell.csv"</span>,</span><br><span class="line">    head=<span class="literal">TRUE</span></span><br><span class="line">  );</span><br><span class="line">&gt; barcodes = barcodes[<span class="number">2</span>:nrow(barcodes),];</span><br><span class="line">&gt; promoter_ratio = (barcodes$promoter_region_fragments+<span class="number">1</span>) / (barcodes$passed_filters + <span class="number">1</span>);</span><br><span class="line">&gt; UMI = log(barcodes$passed_filters+<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">&gt; data = data.frame(UMI=UMI, promoter_ratio=promoter_ratio);</span><br><span class="line">&gt; barcodes$promoter_ratio = promoter_ratio;</span><br><span class="line">&gt; <span class="keyword">library</span>(viridisLite);</span><br><span class="line">&gt; <span class="keyword">library</span>(ggplot2);</span><br><span class="line">&gt; p1 = ggplot(</span><br><span class="line">    data, </span><br><span class="line">    aes(x= UMI, y= promoter_ratio)) + </span><br><span class="line">    geom_point(size=<span class="number">0.1</span>, col=<span class="string">"grey"</span>) +</span><br><span class="line">    theme_classic() +</span><br><span class="line">    ggtitle(<span class="string">"10X Fresh Adult Brain"</span>) +</span><br><span class="line">    ylim(<span class="number">0</span>, <span class="number">1</span>) + xlim(<span class="number">0</span>, <span class="number">6</span>) +</span><br><span class="line">    labs(x = <span class="string">"log10(UMI)"</span>, y=<span class="string">"promoter ratio"</span>) </span><br><span class="line">&gt; p1 </span><br><span class="line">&gt; barcodes.sel = barcodes[which(UMI &gt;= <span class="number">3</span> &amp; UMI &lt;= <span class="number">5</span> &amp; promoter_ratio &gt;= <span class="number">0.15</span> &amp; promoter_ratio &lt;= <span class="number">0.6</span>),];</span><br><span class="line">&gt; rownames(barcodes.sel) = barcodes.sel$barcode;</span><br><span class="line">&gt; x.sp = x.sp[which(x.sp@barcode %<span class="keyword">in</span>% barcodes.sel$barcode),];</span><br><span class="line">&gt; x.sp@metaData = barcodes.sel[x.sp@barcode,];</span><br><span class="line">&gt; x.sp</span><br></pre></td></tr></table></figure>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">## number <span class="keyword">of</span> barcodes: <span class="number">4100</span></span><br><span class="line">## number <span class="keyword">of</span> bins: <span class="number">0</span></span><br><span class="line">## number <span class="keyword">of</span> genes: <span class="number">0</span></span><br><span class="line">## number <span class="keyword">of</span> peaks: <span class="number">0</span></span><br><span class="line">## number <span class="keyword">of</span> motifs: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><img src="http://qd5oognq8.bkt.clouddn.com/scrna2-1-QualityControl.png" width="400" height="400" /></p>
<h2 id="step-2.-add-cell-by-bin-matrix"><a name="add_bmat"></a><strong>Step 2. Add cell-by-bin matrix</strong></h2>
<p>Next, we add the cell-by-bin matrix of 5kb resolution to the snap object. This function will automatically read the cell-by-bin matrix and add it to <mark class="label default"><font color=c52950>bmat</font></mark> slot of snap object.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># show what bin sizes exist in atac_v1_adult_brain_fresh_5k.snap file</span></span><br><span class="line">&gt; showBinSizes(<span class="string">"atac_v1_adult_brain_fresh_5k.snap"</span>);</span><br><span class="line">[<span class="number">1</span>] <span class="number">1000</span> <span class="number">5000</span> <span class="number">10000</span></span><br><span class="line">&gt; x.sp = addBmatToSnap(x.sp, bin.size=<span class="number">5000</span>, num.cores=<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="step-3.-matrix-binarization"><a name="make_binary"></a><strong>Step 3. Matrix binarization</strong></h2>
<p>We will convert the cell-by-bin count matrix to a binary matrix. Some items in the count matrix have abnormally high coverage perhaps due to the alignment errors. Therefore, we next remove 0.1% items of the highest coverage in the count matrix and then convert the remaining non-zero items to 1.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x.sp = makeBinary(x.sp, mat=<span class="string">"bmat"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="step-4.-bin-filtering"><a name="bin_filter"></a><strong>Step 4. Bin filtering</strong></h2>
<p>First, we filter out any bins overlapping with the ENCODE blacklist to prevent from potential artifacts.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; system(<span class="string">"wget http://mitra.stanford.edu/kundaje/akundaje/release/blacklists/mm10-mouse/mm10.blacklist.bed.gz"</span>);</span><br><span class="line">&gt; <span class="keyword">library</span>(GenomicRanges);</span><br><span class="line">&gt; black_list = read.table(<span class="string">"mm10.blacklist.bed.gz"</span>);</span><br><span class="line">&gt; black_list.gr = GRanges(</span><br><span class="line">    black_list[,<span class="number">1</span>], </span><br><span class="line">    IRanges(black_list[,<span class="number">2</span>], black_list[,<span class="number">3</span>])</span><br><span class="line">  );</span><br><span class="line">&gt; idy = queryHits(findOverlaps(x.sp@feature, black_list.gr));</span><br><span class="line">&gt; <span class="keyword">if</span>(length(idy) &gt; <span class="number">0</span>)&#123;x.sp = x.sp[,-idy, mat=<span class="string">"bmat"</span>]&#125;;</span><br><span class="line">&gt; x.sp</span><br></pre></td></tr></table></figure>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">## number <span class="keyword">of</span> barcodes: <span class="number">4100</span></span><br><span class="line">## number <span class="keyword">of</span> bins: <span class="number">546103</span></span><br><span class="line">## number <span class="keyword">of</span> genes: <span class="number">0</span></span><br><span class="line">## number <span class="keyword">of</span> peaks: <span class="number">0</span></span><br><span class="line">## number <span class="keyword">of</span> motifs: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Second, we remove unwanted chromosomes.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; chr.exclude = seqlevels(x.sp@feature)[grep(<span class="string">"random|chrM"</span>, seqlevels(x.sp@feature))];</span><br><span class="line">&gt; idy = grep(paste(chr.exclude, collapse=<span class="string">"|"</span>), x.sp@feature);</span><br><span class="line">&gt; <span class="keyword">if</span>(length(idy) &gt; <span class="number">0</span>)&#123;x.sp = x.sp[,-idy, mat=<span class="string">"bmat"</span>]&#125;;</span><br><span class="line">&gt; x.sp</span><br></pre></td></tr></table></figure>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">## number <span class="keyword">of</span> barcodes: <span class="number">4100</span></span><br><span class="line">## number <span class="keyword">of</span> bins: <span class="number">545183</span></span><br><span class="line">## number <span class="keyword">of</span> genes: <span class="number">0</span></span><br><span class="line">## number <span class="keyword">of</span> peaks: <span class="number">0</span></span><br><span class="line">## number <span class="keyword">of</span> motifs: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Third, the bin coverage roughly obeys a log normal distribution. We remove the top 5% bins that overlap with invariant features such as promoters of the house keeping genes.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; bin.cov = log10(Matrix::colSums(x.sp@bmat)+<span class="number">1</span>);</span><br><span class="line">&gt; hist(</span><br><span class="line">    bin.cov[bin.cov &gt; <span class="number">0</span>], </span><br><span class="line">    xlab=<span class="string">"log10(bin cov)"</span>, </span><br><span class="line">    main=<span class="string">"log10(Bin Cov)"</span>, </span><br><span class="line">    col=<span class="string">"lightblue"</span>, </span><br><span class="line">    xlim=c(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">  );</span><br><span class="line">&gt; bin.cutoff = quantile(bin.cov[bin.cov &gt; <span class="number">0</span>], <span class="number">0.95</span>);</span><br><span class="line">&gt; idy = which(bin.cov &lt;= bin.cutoff &amp; bin.cov &gt; <span class="number">0</span>);</span><br><span class="line">&gt; x.sp = x.sp[, idy, mat=<span class="string">"bmat"</span>];</span><br><span class="line">&gt; x.sp</span><br></pre></td></tr></table></figure>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">## number <span class="keyword">of</span> barcodes: <span class="number">4100</span></span><br><span class="line">## number <span class="keyword">of</span> bins: <span class="number">474624</span></span><br><span class="line">## number <span class="keyword">of</span> genes: <span class="number">0</span></span><br><span class="line">## number <span class="keyword">of</span> peaks: <span class="number">0</span></span><br><span class="line">## number <span class="keyword">of</span> motifs: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><img src="http://qd5oognq8.bkt.clouddn.com/scrna2-2-BinCovDist.png" width="400" height="400" /></p>
<h2 id="step-5.-dimensionality-reduction"><a name="diffusion_maps"></a><strong>Step 5. Dimensionality reduction</strong></h2>
<p>We compute diffusion maps for dimentionality reduction.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x.sp = runDiffusionMaps(</span><br><span class="line">    obj=x.sp,</span><br><span class="line">    input.mat=<span class="string">"bmat"</span>, </span><br><span class="line">    num.eigs=<span class="number">50</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<h2 id="step-6.-determine-significant-components"><a name="pc_select"></a><strong>Step 6. Determine significant components</strong></h2>
<p>We next determine the number of reduced dimensions to include for downstream analysis. We use an ad hoc method by simply looking at a pairwise plot and select the number of dimensions in which the scatter plot starts looking like a blob. In the below example, we choose the first 20 dimensions.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; plotDimReductPW(</span><br><span class="line">    obj=x.sp, </span><br><span class="line">    eigs.dims=<span class="number">1</span>:<span class="number">50</span>,</span><br><span class="line">    point.size=<span class="number">0.3</span>,</span><br><span class="line">    point.color=<span class="string">"grey"</span>,</span><br><span class="line">    point.shape=<span class="number">19</span>,</span><br><span class="line">    point.alpha=<span class="number">0.6</span>,</span><br><span class="line">    down.sample=<span class="number">5000</span>,</span><br><span class="line">    pdf.file.name=<span class="literal">NULL</span>, </span><br><span class="line">    pdf.height=<span class="number">7</span>, </span><br><span class="line">    pdf.width=<span class="number">7</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p><img src="http://qd5oognq8.bkt.clouddn.com/scrna2-3-eigs_scatter_plot.png" width="900" height="900" /></p>
<h2 id="step-7.-graph-based-clustering"><a name="cluster"></a><strong>Step 7. Graph-based clustering</strong></h2>
<p>Using the selected significant dimensions, we next construct a K Nearest Neighbor (KNN) Graph (k=15). Each cell is a node and the k-nearest neighbors of each cell are identified according to the Euclidian distance and edges are draw between neighbors in the graph.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x.sp = runKNN(</span><br><span class="line">    obj=x.sp,</span><br><span class="line">    eigs.dims=<span class="number">1</span>:<span class="number">20</span>,</span><br><span class="line">    k=<span class="number">15</span></span><br><span class="line">  );</span><br><span class="line">&gt; x.sp=runCluster(</span><br><span class="line">    obj=x.sp,</span><br><span class="line">    tmp.folder=tempdir(),</span><br><span class="line">    louvain.lib=<span class="string">"R-igraph"</span>,</span><br><span class="line">    seed.use=<span class="number">10</span></span><br><span class="line">  );</span><br><span class="line">&gt; x.sp@metaData$cluster = x.sp@cluster;</span><br></pre></td></tr></table></figure>
<h2 id="step-8.-visualization"><a name="viz"></a><strong>Step 8. Visualization</strong></h2>
<p>SnapATAC visualizes and explores the data using tSNE (FI-tsne) or UMAP. In this example, we compute the t-SNE embedding. We next project the sequencing depth or other bias onto the t-SNE embedding.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x.sp = runViz(</span><br><span class="line">    obj=x.sp, </span><br><span class="line">    tmp.folder=tempdir(),</span><br><span class="line">    dims=<span class="number">2</span>,</span><br><span class="line">    eigs.dims=<span class="number">1</span>:<span class="number">20</span>, </span><br><span class="line">    method=<span class="string">"Rtsne"</span>,</span><br><span class="line">    seed.use=<span class="number">10</span></span><br><span class="line">  );</span><br><span class="line">&gt; par(mfrow = c(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">&gt; plotViz(</span><br><span class="line">    obj=x.sp,</span><br><span class="line">    method=<span class="string">"tsne"</span>, </span><br><span class="line">    main=<span class="string">"10X Brain Cluster"</span>,</span><br><span class="line">    point.color=x.sp@cluster, </span><br><span class="line">    point.size=<span class="number">1</span>, </span><br><span class="line">    point.shape=<span class="number">19</span>, </span><br><span class="line">    point.alpha=<span class="number">0.8</span>, </span><br><span class="line">    text.add=<span class="literal">TRUE</span>,</span><br><span class="line">    text.size=<span class="number">1.5</span>,</span><br><span class="line">    text.color=<span class="string">"black"</span>,</span><br><span class="line">    text.halo.add=<span class="literal">TRUE</span>,</span><br><span class="line">    text.halo.color=<span class="string">"white"</span>,</span><br><span class="line">    text.halo.width=<span class="number">0.2</span>,</span><br><span class="line">    down.sample=<span class="number">10000</span>,</span><br><span class="line">    legend.add=<span class="literal">FALSE</span></span><br><span class="line">  );</span><br><span class="line">&gt; plotFeatureSingle(</span><br><span class="line">    obj=x.sp,</span><br><span class="line">    feature.value=log(x.sp@metaData[,<span class="string">"passed_filters"</span>]+<span class="number">1</span>,<span class="number">10</span>),</span><br><span class="line">    method=<span class="string">"tsne"</span>, </span><br><span class="line">    main=<span class="string">"10X Brain Read Depth"</span>,</span><br><span class="line">    point.size=<span class="number">0.2</span>, </span><br><span class="line">    point.shape=<span class="number">19</span>, </span><br><span class="line">    down.sample=<span class="number">10000</span>,</span><br><span class="line">    quantiles=c(<span class="number">0.01</span>, <span class="number">0.99</span>)</span><br><span class="line">  ); </span><br><span class="line">&gt; plotFeatureSingle(</span><br><span class="line">    obj=x.sp,</span><br><span class="line">    feature.value=x.sp@metaData$peak_region_fragments / x.sp@metaData$passed_filters,</span><br><span class="line">    method=<span class="string">"tsne"</span>, </span><br><span class="line">    main=<span class="string">"10X Brain FRiP"</span>,</span><br><span class="line">    point.size=<span class="number">0.2</span>, </span><br><span class="line">    point.shape=<span class="number">19</span>, </span><br><span class="line">    down.sample=<span class="number">10000</span>,</span><br><span class="line">    quantiles=c(<span class="number">0.01</span>, <span class="number">0.99</span>) <span class="comment"># remove outliers</span></span><br><span class="line">  );</span><br><span class="line">&gt; plotFeatureSingle(</span><br><span class="line">    obj=x.sp,</span><br><span class="line">    feature.value=x.sp@metaData$duplicate / x.sp@metaData$total,</span><br><span class="line">    method=<span class="string">"tsne"</span>, </span><br><span class="line">    main=<span class="string">"10X Brain Duplicate"</span>,</span><br><span class="line">    point.size=<span class="number">0.2</span>, </span><br><span class="line">    point.shape=<span class="number">19</span>, </span><br><span class="line">    down.sample=<span class="number">10000</span>,</span><br><span class="line">    quantiles=c(<span class="number">0.01</span>, <span class="number">0.99</span>) <span class="comment"># remove outliers</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p><img src="http://qd5oognq8.bkt.clouddn.com/scrna2-4-Visulization.png" width="900" height="900" /></p>
<h2 id="step-9.-gene-based-annotation"><a name="gene_tsne"></a><strong>Step 9. Gene based annotation</strong></h2>
<p>To help annotate identified cell clusters, SnapATAC next creates the cell-by-gene matrix and visualize the enrichment of marker genes.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; system(<span class="string">"wget http://renlab.sdsc.edu/r3fang/share/github/Mouse_Brain_10X/gencode.vM16.gene.bed"</span>);</span><br><span class="line">&gt; genes = read.table(<span class="string">"gencode.vM16.gene.bed"</span>);</span><br><span class="line">&gt; genes.gr = GRanges(genes[,<span class="number">1</span>], </span><br><span class="line">    IRanges(genes[,<span class="number">2</span>], genes[,<span class="number">3</span>]), name=genes[,<span class="number">4</span>]</span><br><span class="line">  );</span><br><span class="line">&gt; marker.genes = c(</span><br><span class="line">    <span class="string">"Snap25"</span>, <span class="string">"Gad2"</span>, <span class="string">"Apoe"</span>,</span><br><span class="line">    <span class="string">"C1qb"</span>, <span class="string">"Pvalb"</span>, <span class="string">"Vip"</span>, </span><br><span class="line">    <span class="string">"Sst"</span>, <span class="string">"Lamp5"</span>, <span class="string">"Slc17a7"</span></span><br><span class="line">  );</span><br><span class="line">&gt; genes.sel.gr &lt;- genes.gr[which(genes.gr$name %<span class="keyword">in</span>% marker.genes)];</span><br><span class="line"><span class="comment"># re-add the cell-by-bin matrix to the snap object;</span></span><br><span class="line">&gt; x.sp = addBmatToSnap(x.sp);</span><br><span class="line">&gt; x.sp = createGmatFromMat(</span><br><span class="line">    obj=x.sp, </span><br><span class="line">    input.mat=<span class="string">"bmat"</span>,</span><br><span class="line">    genes=genes.sel.gr,</span><br><span class="line">    do.par=<span class="literal">TRUE</span>,</span><br><span class="line">    num.cores=<span class="number">10</span></span><br><span class="line">  );</span><br><span class="line"><span class="comment"># normalize the cell-by-gene matrix</span></span><br><span class="line">&gt; x.sp = scaleCountMatrix(</span><br><span class="line">    obj=x.sp, </span><br><span class="line">    cov=x.sp@metaData$passed_filters + <span class="number">1</span>,</span><br><span class="line">    mat=<span class="string">"gmat"</span>,</span><br><span class="line">    method = <span class="string">"RPM"</span></span><br><span class="line">  );</span><br><span class="line"><span class="comment"># smooth the cell-by-gene matrix</span></span><br><span class="line">&gt; x.sp = runMagic(</span><br><span class="line">    obj=x.sp,</span><br><span class="line">    input.mat=<span class="string">"gmat"</span>,</span><br><span class="line">    step.size=<span class="number">3</span></span><br><span class="line">  );</span><br><span class="line">&gt; par(mfrow = c(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">&gt; <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">9</span>)&#123;</span><br><span class="line">    plotFeatureSingle(</span><br><span class="line">        obj=x.sp,</span><br><span class="line">        feature.value=x.sp@gmat[, marker.genes[i]],</span><br><span class="line">        method=<span class="string">"tsne"</span>, </span><br><span class="line">        main=marker.genes[i],</span><br><span class="line">        point.size=<span class="number">0.1</span>, </span><br><span class="line">        point.shape=<span class="number">19</span>, </span><br><span class="line">        down.sample=<span class="number">10000</span>,</span><br><span class="line">        quantiles=c(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  )&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://qd5oognq8.bkt.clouddn.com/scrna2-5-gene_plot.png" width="900" height="900" /></p>
<h2 id="step-10.-heretical-clustering"><a name="heretical_clustering"></a><strong>Step 10. Heretical clustering</strong></h2>
<p>Next, cells belonging to the same cluster are pooled to create the aggregate signal for heretical clustering.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># calculate the ensemble signals for each cluster</span></span><br><span class="line">&gt; ensemble.ls = lapply(split(seq(length(x.sp@cluster)), x.sp@cluster), <span class="keyword">function</span>(x)&#123;</span><br><span class="line">	SnapATAC::colMeans(x.sp[x,], mat=<span class="string">"bmat"</span>);</span><br><span class="line">	&#125;)</span><br><span class="line"><span class="comment"># cluster using 1-cor as distance  </span></span><br><span class="line">&gt; hc = hclust(as.dist(<span class="number">1</span> - cor(t(do.call(rbind, ensemble.ls)))), method=<span class="string">"ward.D2"</span>);</span><br><span class="line">&gt; plotViz(</span><br><span class="line">    obj=x.sp,</span><br><span class="line">    method=<span class="string">"tsne"</span>, </span><br><span class="line">    main=<span class="string">"10X Brain Cluster"</span>,</span><br><span class="line">    point.color=x.sp@cluster, </span><br><span class="line">    point.size=<span class="number">1</span>, </span><br><span class="line">    point.shape=<span class="number">19</span>, </span><br><span class="line">    point.alpha=<span class="number">0.8</span>, </span><br><span class="line">    text.add=<span class="literal">TRUE</span>,</span><br><span class="line">    text.size=<span class="number">1.5</span>,</span><br><span class="line">    text.color=<span class="string">"black"</span>,</span><br><span class="line">    text.halo.add=<span class="literal">TRUE</span>,</span><br><span class="line">    text.halo.color=<span class="string">"white"</span>,</span><br><span class="line">    text.halo.width=<span class="number">0.2</span>,</span><br><span class="line">    down.sample=<span class="number">10000</span>,</span><br><span class="line">    legend.add=<span class="literal">FALSE</span></span><br><span class="line">    );</span><br><span class="line">&gt; plot(hc, hang=-<span class="number">1</span>, xlab=<span class="string">""</span>);</span><br></pre></td></tr></table></figure>
<p>In this case, from cluster 20 to 25 are excitatory neuron; cluster 19 to 5 are inhibitory neurons and the rest of them are non-neuronal cells.</p>
<p><img src="http://qd5oognq8.bkt.clouddn.com/scrna2-6-Visulization_tsne.png" width="400" height="400" /> <img src="http://qd5oognq8.bkt.clouddn.com/scrna2-7-cluster_tree.png" width="400" height="400" /></p>
<h2 id="step-11.-identify-peaks"><a name="peak_call"></a><strong>Step 11. Identify peaks</strong></h2>
<p>Next we aggregate cells from the each cluster to create an ensemble track for peak calling and visualization. This step will generate a .narrowPeak file that contains the identified peak and .bedGraph file for visualization. To obtain the most robust result, we don't recommend to perform this step for clusters with cell number less than 100. In the below example, SnapATAC creates <mark class="label default"><font color=c52950>atac_v1_adult_brain_fresh_5k.1_peaks.narrowPeak</font></mark> and <mark class="label default"><font color=c52950>atac_v1_adult_brain_fresh_5k.1_treat_pileup.bdg</font></mark>. bdg file can be compressed to bigWig file using bedGraphToBigWig for IGV or Genome Browser visulization.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; system(<span class="string">"which snaptools"</span>)</span><br><span class="line">/home/r3fang/anaconda2/bin/snaptools</span><br><span class="line">&gt; system(<span class="string">"which macs2"</span>)</span><br><span class="line">/home/r3fang/anaconda2/bin/macs2</span><br><span class="line">&gt; runMACS(</span><br><span class="line">	obj=x.sp[which(x.sp@cluster==<span class="number">1</span>),], </span><br><span class="line">	output.prefix=<span class="string">"atac_v1_adult_brain_fresh_5k.1"</span>,</span><br><span class="line">	path.to.snaptools=<span class="string">"/home/r3fang/anaconda2/bin/snaptools"</span>,</span><br><span class="line">	path.to.macs=<span class="string">"/home/r3fang/anaconda2/bin/macs2"</span>,</span><br><span class="line">	gsize=<span class="string">"mm"</span>, </span><br><span class="line">	buffer.size=<span class="number">500</span>, </span><br><span class="line">	num.cores=<span class="number">5</span>,</span><br><span class="line">	macs.options=<span class="string">"--nomodel --shift 37 --ext 73 --qval 1e-2 -B --SPMR --call-summits"</span>,</span><br><span class="line">	tmp.folder=tempdir()</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
<p>Next, we provide a short script that performs this step for all clusters.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># call peaks for all cluster with more than 100 cells</span></span><br><span class="line">&gt; clusters.sel = names(table(x.sp@cluster))[which(table(x.sp@cluster) &gt; <span class="number">200</span>)];</span><br><span class="line">&gt; peaks.ls = mclapply(seq(clusters.sel), <span class="keyword">function</span>(i)&#123;</span><br><span class="line">    print(clusters.sel[i]);</span><br><span class="line">    runMACS(</span><br><span class="line">        obj=x.sp[which(x.sp@cluster==clusters.sel[i]),], </span><br><span class="line">        output.prefix=paste0(<span class="string">"atac_v1_adult_brain_fresh_5k."</span>, gsub(<span class="string">" "</span>, <span class="string">"_"</span>, clusters.sel)[i]),</span><br><span class="line">        path.to.snaptools=<span class="string">"/home/r3fang/anaconda2/bin/snaptools"</span>,</span><br><span class="line">        path.to.macs=<span class="string">"/home/r3fang/anaconda2/bin/macs2"</span>,</span><br><span class="line">        gsize=<span class="string">"hs"</span>, <span class="comment"># mm, hs, etc</span></span><br><span class="line">        buffer.size=<span class="number">500</span>, </span><br><span class="line">        num.cores=<span class="number">1</span>,</span><br><span class="line">        macs.options=<span class="string">"--nomodel --shift 100 --ext 200 --qval 5e-2 -B --SPMR"</span>,</span><br><span class="line">        tmp.folder=tempdir()</span><br><span class="line">   );</span><br><span class="line"> &#125;, mc.cores=<span class="number">5</span>);</span><br><span class="line"><span class="comment"># assuming all .narrowPeak files in the current folder are generated from the clusters</span></span><br><span class="line">&gt; peaks.names = system(<span class="string">"ls | grep narrowPeak"</span>, intern=<span class="literal">TRUE</span>);</span><br><span class="line">&gt; peak.gr.ls = lapply(peaks.names, <span class="keyword">function</span>(x)&#123;</span><br><span class="line">    peak.df = read.table(x)</span><br><span class="line">    GRanges(peak.df[,<span class="number">1</span>], IRanges(peak.df[,<span class="number">2</span>], peak.df[,<span class="number">3</span>]))</span><br><span class="line">  &#125;)</span><br><span class="line">&gt; peak.gr = reduce(Reduce(c, peak.gr.ls));</span><br><span class="line">&gt; peak.gr</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">## GRanges object with <span class="number">242847</span> ranges <span class="keyword">and</span> <span class="number">0</span> metadata columns:</span><br><span class="line">##           seqnames               ranges strand</span><br><span class="line">##              &lt;Rle&gt;            &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">##       [<span class="number">1</span>]     chr1   [<span class="number">3094889</span>, <span class="number">3095629</span>]      *</span><br><span class="line">##       [<span class="number">2</span>]     chr1   [<span class="number">3113499</span>, <span class="number">3114060</span>]      *</span><br><span class="line">##       [<span class="number">3</span>]     chr1   [<span class="number">3118103</span>, <span class="number">3118401</span>]      *</span><br><span class="line">##       [<span class="number">4</span>]     chr1   [<span class="number">3119689</span>, <span class="number">3120845</span>]      *</span><br><span class="line">##       [<span class="number">5</span>]     chr1   [<span class="number">3121534</span>, <span class="number">3121786</span>]      *</span><br><span class="line">##       ...      ...                  ...    ...</span><br><span class="line">##  [<span class="number">242843</span>]     chrY [<span class="number">90797373</span>, <span class="number">90798136</span>]      *</span><br><span class="line">##  [<span class="number">242844</span>]     chrY [<span class="number">90804709</span>, <span class="number">90805456</span>]      *</span><br><span class="line">##  [<span class="number">242845</span>]     chrY [<span class="number">90808580</span>, <span class="number">90808819</span>]      *</span><br><span class="line">##  [<span class="number">242846</span>]     chrY [<span class="number">90808850</span>, <span class="number">90809131</span>]      *</span><br><span class="line">##  [<span class="number">242847</span>]     chrY [<span class="number">90810817</span>, <span class="number">90811057</span>]      *</span><br><span class="line">##  -------</span><br></pre></td></tr></table></figure>
<h2 id="step-12.-create-a-cell-by-peak-matrix"><a name="create_pmat"></a><strong>Step 12. Create a cell-by-peak matrix</strong></h2>
<p>Using merged peak list as a reference, we next create a cell-by-peak matrix using the original snap file.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; peaks.df = as.data.frame(peak.gr)[,<span class="number">1</span>:<span class="number">3</span>];</span><br><span class="line">&gt; write.table(peaks.df,file = <span class="string">"peaks.combined.bed"</span>,append=<span class="literal">FALSE</span>,</span><br><span class="line">		quote= <span class="literal">FALSE</span>,sep=<span class="string">"\t"</span>, eol = <span class="string">"\n"</span>, na = <span class="string">"NA"</span>, dec = <span class="string">"."</span>, </span><br><span class="line">		row.names = <span class="literal">FALSE</span>, col.names = <span class="literal">FALSE</span>, qmethod = c(<span class="string">"escape"</span>, <span class="string">"double"</span>),</span><br><span class="line">		fileEncoding = <span class="string">""</span>)</span><br><span class="line">&gt; saveRDS(x.sp, file=<span class="string">"atac_v1_adult_brain_fresh_5k.snap.rds"</span>);</span><br></pre></td></tr></table></figure>
<p>Next we create cell-by-peak matrix and add to the snap file. This step will take a while.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ snaptools snap-add-pmat \</span><br><span class="line">	--snap-file atac_v1_adult_brain_fresh_5k.snap \</span><br><span class="line">	--peak-file peaks.combined.bed</span><br></pre></td></tr></table></figure>
<h2 id="step-13.-add-cell-by-peak-matrix"><a name="add_pmat"></a><strong>Step 13. Add cell-by-peak matrix</strong></h2>
<p>Next we add the cell-by-peak matrix to the existing snap object.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x.sp = readRDS(<span class="string">"atac_v1_adult_brain_fresh_5k.snap.rds"</span>);</span><br><span class="line">&gt; x.sp = addPmatToSnap(x.sp);</span><br><span class="line">&gt; x.sp = makeBinary(x.sp, mat=<span class="string">"pmat"</span>);</span><br><span class="line">&gt; x.sp</span><br></pre></td></tr></table></figure>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">## number <span class="keyword">of</span> barcodes: <span class="number">4100</span></span><br><span class="line">## number <span class="keyword">of</span> bins: <span class="number">546206</span></span><br><span class="line">## number <span class="keyword">of</span> genes: <span class="number">16</span></span><br><span class="line">## number <span class="keyword">of</span> peaks: <span class="number">242847</span></span><br><span class="line">## number <span class="keyword">of</span> motifs: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="step-14.-identify-differentially-accessible-regions"><a name="diff_analysis"></a><strong>Step 14. Identify differentially accessible regions</strong></h2>
<p>SnapATAC finds differentially accessible regions (DARs) that define clusters via differential analysis. By default, it identifies positive peaks of a single cluster (specified in <mark class="label default"><font color=c52950>cluster.pos</font></mark>), compared to a group of negative control cells. If by default <mark class="label default"><font color=c52950>cluster.neg=NULL</font></mark>, findDAR will look for a group of background cells closest to the positive cells.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; DARs = findDAR(</span><br><span class="line">    obj=x.sp,</span><br><span class="line">    input.mat=<span class="string">"pmat"</span>,</span><br><span class="line">    cluster.pos=<span class="number">26</span>,</span><br><span class="line">    cluster.neg.method=<span class="string">"knn"</span>,</span><br><span class="line">    test.method=<span class="string">"exactTest"</span>,</span><br><span class="line">    bcv=<span class="number">0.1</span>, <span class="comment">#0.4 for human, 0.1 for mouse</span></span><br><span class="line">    seed.use=<span class="number">10</span></span><br><span class="line">  );</span><br><span class="line">&gt; DARs$FDR = p.adjust(DARs$PValue, method=<span class="string">"BH"</span>);</span><br><span class="line">&gt; idy = which(DARs$FDR &lt; <span class="number">5e-2</span> &amp; DARs$logFC &gt; <span class="number">0</span>);</span><br><span class="line">&gt; par(mfrow = c(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&gt; plot(DARs$logCPM, DARs$logFC, </span><br><span class="line">    pch=<span class="number">19</span>, cex=<span class="number">0.1</span>, col=<span class="string">"grey"</span>, </span><br><span class="line">    ylab=<span class="string">"logFC"</span>, xlab=<span class="string">"logCPM"</span>,</span><br><span class="line">    main=<span class="string">"Cluster 26"</span></span><br><span class="line">  );</span><br><span class="line">&gt; points(DARs$logCPM[idy], </span><br><span class="line">    DARs$logFC[idy], </span><br><span class="line">    pch=<span class="number">19</span>, </span><br><span class="line">    cex=<span class="number">0.5</span>, </span><br><span class="line">    col=<span class="string">"red"</span></span><br><span class="line">  );</span><br><span class="line">&gt; abline(h = <span class="number">0</span>, lwd=<span class="number">1</span>, lty=<span class="number">2</span>);</span><br><span class="line">&gt; covs = Matrix::rowSums(x.sp@pmat);</span><br><span class="line">&gt; vals = Matrix::rowSums(x.sp@pmat[,idy]) / covs;</span><br><span class="line">&gt; vals.zscore = (vals - mean(vals)) / sd(vals);</span><br><span class="line">&gt; plotFeatureSingle(</span><br><span class="line">    obj=x.sp,</span><br><span class="line">    feature.value=vals.zscore,</span><br><span class="line">    method=<span class="string">"tsne"</span>, </span><br><span class="line">    main=<span class="string">"Cluster 26"</span>,</span><br><span class="line">    point.size=<span class="number">0.1</span>, </span><br><span class="line">    point.shape=<span class="number">19</span>, </span><br><span class="line">    down.sample=<span class="number">5000</span>,</span><br><span class="line">    quantiles=c(<span class="number">0.01</span>, <span class="number">0.99</span>)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p><img src="http://qd5oognq8.bkt.clouddn.com/scrna2-8-DARs.png" width="700" height="350" /></p>
<p>Next, we identify DARs for each of the clusters. For clusters, especially the small ones, that lack the static power to reveal DARs, we rank the peaks based on the enrichment and use the top 2000 peaks as representative peaks for motif discovery.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; idy.ls = lapply(levels(x.sp@cluster), <span class="keyword">function</span>(cluster_i)&#123;</span><br><span class="line">	DARs = findDAR(</span><br><span class="line">		obj=x.sp,</span><br><span class="line">		input.mat=<span class="string">"pmat"</span>,</span><br><span class="line">		cluster.pos=cluster_i,</span><br><span class="line">		cluster.neg=<span class="literal">NULL</span>,</span><br><span class="line">		cluster.neg.method=<span class="string">"knn"</span>,</span><br><span class="line">		bcv=<span class="number">0.1</span>,</span><br><span class="line">		test.method=<span class="string">"exactTest"</span>,</span><br><span class="line">		seed.use=<span class="number">10</span></span><br><span class="line">		);</span><br><span class="line">	DARs$FDR = p.adjust(DARs$PValue, method=<span class="string">"BH"</span>);</span><br><span class="line">	idy = which(DARs$FDR &lt; <span class="number">5e-2</span> &amp; DARs$logFC &gt; <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>((x=length(idy)) &lt; <span class="number">2000L</span>)&#123;</span><br><span class="line">			PValues = DARs$PValue;</span><br><span class="line">			PValues[DARs$logFC &lt; <span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			idy = order(PValues, decreasing=<span class="literal">FALSE</span>)[<span class="number">1</span>:<span class="number">2000</span>];</span><br><span class="line">			rm(PValues); <span class="comment"># free memory</span></span><br><span class="line">	&#125;</span><br><span class="line">	idy</span><br><span class="line">  &#125;)</span><br><span class="line">&gt; names(idy.ls) = levels(x.sp@cluster);</span><br><span class="line">&gt; par(mfrow = c(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">&gt; <span class="keyword">for</span>(cluster_i <span class="keyword">in</span> levels(x.sp@cluster))&#123;</span><br><span class="line">	print(cluster_i)</span><br><span class="line">	idy = idy.ls[[cluster_i]];</span><br><span class="line">	vals = Matrix::rowSums(x.sp@pmat[,idy]) / covs;</span><br><span class="line">	vals.zscore = (vals - mean(vals)) / sd(vals);</span><br><span class="line">	plotFeatureSingle(</span><br><span class="line">		obj=x.sp,</span><br><span class="line">		feature.value=vals.zscore,</span><br><span class="line">		method=<span class="string">"tsne"</span>, </span><br><span class="line">		main=cluster_i,</span><br><span class="line">		point.size=<span class="number">0.1</span>, </span><br><span class="line">		point.shape=<span class="number">19</span>, </span><br><span class="line">		down.sample=<span class="number">5000</span>,</span><br><span class="line">		quantiles=c(<span class="number">0.01</span>, <span class="number">0.99</span>)</span><br><span class="line">		);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://qd5oognq8.bkt.clouddn.com/scrna2-9-DARs_all.png" width="900" height="900" /></p>
<h2 id="step-15.-motif-analysis-identifies-master-regulators"><a name="homer_chromVAR"></a><strong>Step 15. Motif analysis identifies master regulators</strong></h2>
<p>SnapATAC employs Homer to identify master regulators that are enriched in the differentially accessible regions (DARs). This will creates a homer motif report <mark class="label default"><font color=c52950>knownResults.html</font></mark> in the folder <mark class="label default"><font color=c52950>./homer/C5</font></mark>. This requires Homer to be pre-installed. See <span class="exturl" data-url="aHR0cDovL2hvbWVyLnVjc2QuZWR1L2hvbWVyL2ludHJvZHVjdGlvbi9pbnN0YWxsLmh0bWw=">here<i class="fa fa-external-link-alt"></i></span> for the instruction about how to install Homer.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; system(<span class="string">"which findMotifsGenome.pl"</span>);</span><br><span class="line">/projects/ps-renlab/r3fang/public_html/softwares/homer/bin/findMotifsGenome.pl</span><br><span class="line">&gt; motifs = runHomer(</span><br><span class="line">	x.sp[,idy.ls[[<span class="string">"5"</span>]],<span class="string">"pmat"</span>], </span><br><span class="line">	mat = <span class="string">"pmat"</span>,</span><br><span class="line">	path.to.homer = <span class="string">"/projects/ps-renlab/r3fang/public_html/softwares/homer/bin/findMotifsGenome.pl"</span>,</span><br><span class="line">	result.dir = <span class="string">"./homer/C5"</span>,</span><br><span class="line">	num.cores=<span class="number">5</span>,</span><br><span class="line">	genome = <span class="string">'mm10'</span>,</span><br><span class="line">	motif.length = <span class="number">10</span>,</span><br><span class="line">	scan.size = <span class="number">300</span>,</span><br><span class="line">	optimize.count = <span class="number">2</span>,</span><br><span class="line">	background = <span class="string">'automatic'</span>,</span><br><span class="line">	local.background = <span class="literal">FALSE</span>,</span><br><span class="line">	only.known = <span class="literal">TRUE</span>,</span><br><span class="line">	only.denovo = <span class="literal">FALSE</span>,</span><br><span class="line">	fdr.num = <span class="number">5</span>,</span><br><span class="line">	cache = <span class="number">100</span>,</span><br><span class="line">	overwrite = <span class="literal">TRUE</span>,</span><br><span class="line">	keep.minimal = <span class="literal">FALSE</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p>See <span class="exturl" data-url="aHR0cDovL3JlbmxhYi5zZHNjLmVkdS9yM2Zhbmcvc2hhcmUvZ2l0aHViL01vdXNlX0JyYWluXzEwWC9ob21lci9DNS9rbm93blJlc3VsdHMuaHRtbA==">here<i class="fa fa-external-link-alt"></i></span> for the full list of motifs for cluster 5.</p>
<p><img src="http://qd5oognq8.bkt.clouddn.com/scrna2-10-homer_motif.png" width="900" height="400" /></p>
<p>SnapATAC also incorporates chromVAR (Schep et al) for motif variability analysis.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(chromVAR);</span><br><span class="line">&gt; <span class="keyword">library</span>(motifmatchr);</span><br><span class="line">&gt; <span class="keyword">library</span>(SummarizedExperiment);</span><br><span class="line">&gt; <span class="keyword">library</span>(BSgenome.Mmusculus.UCSC.mm10);</span><br><span class="line">&gt; x.sp = makeBinary(x.sp, <span class="string">"pmat"</span>);</span><br><span class="line">&gt; x.sp@mmat = runChromVAR(</span><br><span class="line">    obj=x.sp,</span><br><span class="line">    input.mat=<span class="string">"pmat"</span>,</span><br><span class="line">    genome=BSgenome.Mmusculus.UCSC.mm10,</span><br><span class="line">    min.count=<span class="number">10</span>,</span><br><span class="line">    species=<span class="string">"Homo sapiens"</span></span><br><span class="line">  );</span><br><span class="line">&gt; motif_i = <span class="string">"MA0497.1_MEF2C"</span>;</span><br><span class="line">&gt; dat = data.frame(x=x.sp@metaData[,<span class="string">"cluster"</span>], y=x.sp@mmat[,motif_i]);</span><br><span class="line">&gt; p1 &lt;- ggplot(dat, aes(x=x, y=y, fill=x)) + </span><br><span class="line">	theme_classic() +</span><br><span class="line">	geom_violin() + </span><br><span class="line">	xlab(<span class="string">"cluster"</span>) +</span><br><span class="line">	ylab(<span class="string">"motif enrichment"</span>) + </span><br><span class="line">	ggtitle(motif_i) +</span><br><span class="line">	theme(</span><br><span class="line">		  plot.margin = margin(<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>, <span class="string">"cm"</span>),</span><br><span class="line">		  axis.text.x = element_text(angle = <span class="number">90</span>, hjust = <span class="number">1</span>),</span><br><span class="line">		  axis.ticks.x=element_blank(),</span><br><span class="line">		  legend.position = <span class="string">"none"</span></span><br><span class="line">   );</span><br><span class="line">&gt; motif_i = <span class="string">"MA0660.1_MEF2B"</span>;</span><br><span class="line">&gt; dat = data.frame(x=x.sp@metaData[,<span class="string">"cluster"</span>], y=x.sp@mmat[,motif_i]);</span><br><span class="line">&gt; p2 &lt;- ggplot(dat, aes(x=x, y=y, fill=x)) + </span><br><span class="line">	theme_classic() +</span><br><span class="line">	geom_violin() + </span><br><span class="line">	xlab(<span class="string">"cluster"</span>) +</span><br><span class="line">	ylab(<span class="string">"motif enrichment"</span>) + </span><br><span class="line">	ggtitle(motif_i) +</span><br><span class="line">	theme(</span><br><span class="line">		  plot.margin = margin(<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>, <span class="string">"cm"</span>),</span><br><span class="line">		  axis.text.x = element_text(angle = <span class="number">90</span>, hjust = <span class="number">1</span>),</span><br><span class="line">		  axis.ticks.x=element_blank(),</span><br><span class="line">		  legend.position = <span class="string">"none"</span></span><br><span class="line">   );</span><br><span class="line">&gt; p1</span><br><span class="line">&gt; p2</span><br></pre></td></tr></table></figure>
<p><img src="http://qd5oognq8.bkt.clouddn.com/scrna2-11-chromVAR_2B.png" width="900" height="400" /> <img src="http://qd5oognq8.bkt.clouddn.com/scrna2-12-chromVAR_2C.png" width="900" height="400" /></p>
<h2 id="step-16.-great-analysis"><a name="great_analysis"></a><strong>Step 16. GREAT analysis</strong></h2>
<p>SnapATAC applies GREAT to identify biological pathways active in each of the cell cluster. In this example, we will first identify the differential elements in Microglia cells (cluster 13) and report the top 6 GO Ontologies enrichment inferred using GREAT analysis.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## install R package rGREAT</span></span><br><span class="line">&gt; <span class="keyword">if</span> (!requireNamespace(<span class="string">"BiocManager"</span>, quietly=<span class="literal">TRUE</span>))</span><br><span class="line">    install.packages(<span class="string">"BiocManager"</span>)</span><br><span class="line">&gt; BiocManager::install(<span class="string">"rGREAT"</span>)</span><br><span class="line"><span class="comment">## or install the latest version</span></span><br><span class="line">&gt; <span class="keyword">library</span>(devtools)</span><br><span class="line">&gt; install_github(<span class="string">"jokergoo/rGREAT"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(rGREAT);</span><br><span class="line">&gt; DARs = findDAR(</span><br><span class="line">    obj=x.sp,</span><br><span class="line">    input.mat=<span class="string">"pmat"</span>,</span><br><span class="line">    cluster.pos=<span class="number">13</span>,</span><br><span class="line">    cluster.neg.method=<span class="string">"knn"</span>,</span><br><span class="line">    test.method=<span class="string">"exactTest"</span>,</span><br><span class="line">    bcv=<span class="number">0.1</span>, <span class="comment">#0.4 for human, 0.1 for mouse</span></span><br><span class="line">    seed.use=<span class="number">10</span></span><br><span class="line">  );</span><br><span class="line">&gt; DARs$FDR = p.adjust(DARs$PValue, method=<span class="string">"BH"</span>);</span><br><span class="line">&gt; idy = which(DARs$FDR &lt; <span class="number">5e-2</span> &amp; DARs$logFC &gt; <span class="number">0</span>);</span><br><span class="line">&gt; job = submitGreatJob(</span><br><span class="line">    gr                    = x.sp@peak[idy],</span><br><span class="line">    bg                    = <span class="literal">NULL</span>,</span><br><span class="line">    species               = <span class="string">"mm10"</span>,</span><br><span class="line">    includeCuratedRegDoms = <span class="literal">TRUE</span>,</span><br><span class="line">    rule                  = <span class="string">"basalPlusExt"</span>,</span><br><span class="line">    adv_upstream          = <span class="number">5.0</span>,</span><br><span class="line">    adv_downstream        = <span class="number">1.0</span>,</span><br><span class="line">    adv_span              = <span class="number">1000.0</span>,</span><br><span class="line">    adv_twoDistance       = <span class="number">1000.0</span>,</span><br><span class="line">    adv_oneDistance       = <span class="number">1000.0</span>,</span><br><span class="line">    request_interval = <span class="number">300</span>,</span><br><span class="line">    max_tries = <span class="number">10</span>,</span><br><span class="line">    version = <span class="string">"default"</span>,</span><br><span class="line">    base_url = <span class="string">"http://great.stanford.edu/public/cgi-bin"</span></span><br><span class="line">  );</span><br><span class="line">&gt; job</span><br></pre></td></tr></table></figure>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">## Submit time: <span class="number">2019</span><span class="number">-09</span><span class="number">-04</span> <span class="number">14</span>:<span class="number">14</span>:<span class="number">02</span></span><br><span class="line">## Version: default</span><br><span class="line">## Species: mm10</span><br><span class="line">## Inputs: <span class="number">25120</span> regions</span><br><span class="line">## Background: wholeGenome</span><br><span class="line">## Model: Basal plus extension</span><br><span class="line">##   Proximal: <span class="number">5</span> kb upstream, <span class="number">1</span> kb downstream,</span><br><span class="line">##   plus Distal: up to <span class="number">1000</span> kb</span><br><span class="line">## Include curated regulatory domains</span><br><span class="line">## </span><br><span class="line">## Enrichment tables for following ontologies have been downloaded:</span><br><span class="line">##   None</span><br></pre></td></tr></table></figure>
<p>With <code>job</code>, we can now retrieve results from GREAT. The first and the primary results are the tables which contain enrichment statistics for the analysis. By default it will retrieve results from three GO Ontologies and all pathway ontologies. All tables contains statistics for all terms no matter they are significant or not. Users can then make filtering by a self-defined cutoff.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; tb = getEnrichmentTables(job);</span><br><span class="line">&gt; names(tb);</span><br></pre></td></tr></table></figure>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">## [<span class="number">1</span>] <span class="string">"GO Molecular Function"</span> <span class="string">"GO Biological Process"</span> <span class="string">"GO Cellular Component"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; GBP = tb<span class="string">[["GO Biological Process"]]</span>;</span><br><span class="line">&gt; head(GBP[order(GBP[,<span class="string">"Binom_Adjp_BH"</span>]),<span class="number">1</span>:<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">##           ID                                      name Binom_Genome_Fraction</span><br><span class="line">## <span class="number">1</span> GO:<span class="number">0002376</span>                     immune system process            <span class="number">0.12515840</span></span><br><span class="line">## <span class="number">2</span> GO:<span class="number">0002682</span>       regulation of immune system process            <span class="number">0.09012561</span></span><br><span class="line">## <span class="number">3</span> GO:<span class="number">0009987</span>                          cellular process            <span class="number">0.80870120</span></span><br><span class="line">## <span class="number">4</span> GO:<span class="number">0048518</span> positive regulation of biological process            <span class="number">0.43002240</span></span><br><span class="line">## <span class="number">5</span> GO:<span class="number">0050789</span>          regulation of biological process            <span class="number">0.68873070</span></span><br><span class="line">## <span class="number">6</span> GO:<span class="number">0050794</span>            regulation of cellular process            <span class="number">0.66837300</span></span><br><span class="line">##   Binom_Expected Binom_Observed_Region_Hits</span><br><span class="line">## <span class="number">1</span>       <span class="number">3095.918</span>                       <span class="number">5592</span></span><br><span class="line">## <span class="number">2</span>       <span class="number">2229.347</span>                       <span class="number">4148</span></span><br><span class="line">## <span class="number">3</span>      <span class="number">20004.030</span>                      <span class="number">22241</span></span><br><span class="line">## <span class="number">4</span>      <span class="number">10637.030</span>                      <span class="number">13697</span></span><br><span class="line">## <span class="number">5</span>      <span class="number">17036.440</span>                      <span class="number">19871</span></span><br><span class="line">## <span class="number">6</span>      <span class="number">16532.870</span>                      <span class="number">19356</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>scRNA</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>scRNA</tag>
        <tag>ATAC</tag>
      </tags>
  </entry>
  <entry>
    <title>Calculation of KaKs Value</title>
    <url>/posts/539d6d7a/</url>
    <content><![CDATA[<h2 id="the-concept-and-meaning-of-kaks">The concept and meaning of Ka,Ks</h2>
<hr />
<div class="note info no-icon"><p>Ks (synonymous substitutions): A base mutation in a codon does not change the amino acid encoded by the codon. Ka (nonsynonymous substitutions): A base mutation in a codon changes the amino acid encoded by that codon.</p>
</div>
<p><br> <a id="more"></a></p>
<p>DN/dS is equivalent to Ka/Ks, and its meaning is as follows:<br> <div class="note success"><p><strong>Neutral Evolution (drift):</strong> dN/dS ratio = 1 implies there has been equal numbers of synonymous (dna substitutions that do not affect the protein sequence) and non-synonymous changes (dna substitutions that do affect the protein sequence) during the time between ancestral to the modern versions of the protein.</p>
<p><strong>Positive Selection (adaptive evolution):</strong> dN/dS ratio &gt; 1 implies there has been more non-synonymous changes than synonymous changes. There has been evolutionary pressure to escape from the ancestral state - i.e. positive selection pressure. This can occur for example in paralogues that are required to serve a novel function, or in proteins of parasites that need to escape host immune recognition (e.g. changes to avoid MHC-1 binding to evade T-cell attack).</p>
<p><strong>Negative Selection (conservation):</strong> dN/dS ratio &lt; 1 implies there has been more synonymous changes than non-synonymous changes. There has been evolutionary pressure to conserve the ancestral state - i.e. negative selection pressure. This can occur for example in orthologues that are required to maintain (conserve) some function encoded in the protein sequence, since changes from this state would lead to disruption of function.</p>
</div></p>
<h2 id="calculate-kaks">Calculate Ka,Ks</h2>
<hr />
<p>The software KaKs_Calculator is used for calculation, and the input file of the software is an AXT format file at nucleic acid level. The following describes the preparation of axt files and examples of the use of the software.</p>
<p>Suppose there is a protein sequence of the following pair of homologous genes and its corresponding cds sequence.</p>
<p>Protein sequence (example_pep.fas) <figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">&gt;ENSP<span class="number">00000004982</span></span><br><span class="line">MEIPVPVQPSWLRRASAPLPGLSAPGRLFDQRFGEGLLEAELAALCPTTLAPYYLRAPSVALPVAQVPTD</span><br><span class="line">PGHFSVLLDVKHFSPEEIAVKVVGEHVEVHARHEERPDEHGFVAREFHRRYRLPPGVDPAAVTSALSPEG</span><br><span class="line">VLSIQAAPASAQAPPPAAAK</span><br><span class="line">&gt;ENSMUSP<span class="number">00000039172</span></span><br><span class="line">MEIPVPVQPSWLRRASAPLPGFSAPGRLFDQRFGEGLLEAELASLCPAAIAPYYLRAPSVALPTAQVSTD</span><br><span class="line">SGYFSVLLDVKHFLPEEISVKVVDDHVEVHARHEERPDEHGFIAREFHRRYRLPPGVDPAAVTSALSPEG</span><br><span class="line">VLSIQATPASAQAQLPSPPAAK</span><br></pre></td></tr></table></figure></p>
<p>cds sequence（example_cds.fas） <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&gt;ENSP00000004982</span><br><span class="line">ATGGAGATCCCTGTGCCTGTGCAGCCGTCTTGGCTGCGCCGCGCCTCGGCCCCGTTGCCCGGACTTTCGG</span><br><span class="line"><span class="built_in">CGCCCGGACGCCTCTTTGACCAGCGCTTCGGCGAGGGGCTGCTGGAGGCCGAGCTGGCTGCGCTCTGCCC</span></span><br><span class="line"><span class="built_in">CACCACGCTCGCCCCCTACTACCTGCGCGCACCCAGCGTGGCGCTGCCCGTCGCCCAGGTGCCGACGGAC</span></span><br><span class="line">CCCGGCCACTTTTCGGTGCTGCTAGACGTGAAGCACTTCTCGCCGGAGGAAATTGCTGTCAAGGTGGTGG</span><br><span class="line">GCGAACACGTGGAGGTGCACGCGCGCCACGAGGAGCGCCCGGATGAGCACGGATTCGTCGCGCGCGAGTT</span><br><span class="line">CCACCGTCGCTACCGCCTGCCGCCTGGCGTGGATCCGGCTGCCGTGACGTCCGCGCTGTCCCCCGAGGGC</span><br><span class="line">GTCCTGTCCATCCAGGCCGCACCAGCGTCGGCCCAGGCCCCACCGCCAGCCGCAGCCAAGTAG</span><br><span class="line">&gt;ENSMUSP00000039172</span><br><span class="line">ATGGAGATCCCCGTGCCTGTGCAGCCTTCTTGGCTGCGCCGTGCTTCAGCTCCTTTACCAGGTTTCTCTG</span><br><span class="line"><span class="built_in">CTCCGGGACGCCTCTTTGACCAGCGTTTCGGCGAAGGGCTGCTTGAGGCAGAGCTGGCTTCACTGTGCCC</span></span><br><span class="line">TGCTGCGATCGCCCCCTACTATCTGCGCGCCCCCAGTGTGGCGTTACCCACAGCCCAGGTGTCCACGGAC</span><br><span class="line">TCTGGGTATTTTTCCGTGCTGCTGGATGTGAAGCACTTCTTGCCAGAGGAAATCTCTGTCAAGGTGGTTG</span><br><span class="line">ACGACCATGTGGAGGTCCATGCTCGGCACGAGGAGCGCCCGGATGAACACGGATTCATTGCTCGAGAGTT</span><br><span class="line">CCACCGCCGATACCGCCTGCCTCCTGGTGTGGACCCTGCTGCTGTGACCTCAGCACTGTCTCCTGAGGGT</span><br><span class="line">GTCCTGTCCATCCAGGCCACACCAGCGTCGGCCCAGGCCCAACTTCCGTCACCACCTGCTGCCAAGTAG</span><br></pre></td></tr></table></figure></p>
<h3 id="step-1">Step 1:</h3>
<p>Protein sequence matching (alignment)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mafft</span> <span class="selector-tag">--auto</span> <span class="selector-tag">example_pep</span><span class="selector-class">.fas</span> &gt; <span class="selector-tag">example_pep_aln</span><span class="selector-class">.fas</span></span><br></pre></td></tr></table></figure>
<h3 id="step-2">Step 2:</h3>
<p>Convert protein sequence matching into nucleic acid sequence matching <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">perl</span> <span class="selector-tag">pal2nal</span><span class="selector-class">.pl</span> <span class="selector-tag">example_pep_aln</span><span class="selector-class">.fas</span> <span class="selector-tag">example_cds</span><span class="selector-class">.fas</span> <span class="selector-tag">-output</span> <span class="selector-tag">fasta</span> &gt; <span class="selector-tag">example_cds_aln</span><span class="selector-class">.fas</span></span><br></pre></td></tr></table></figure> ### Step 3: Transfer nucleic acid sequences to AXT format <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">python</span> <span class="selector-tag">FastaIntoAXT</span><span class="selector-class">.py</span> <span class="selector-tag">example_cds_aln</span><span class="selector-class">.fas</span> &gt; <span class="selector-tag">example_cds_aln</span><span class="selector-class">.axt</span></span><br></pre></td></tr></table></figure></p>
<p>FastaIntoAXT.py script <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseFasta</span><span class="params">(filename)</span>:</span></span><br><span class="line">    fas = &#123;&#125;</span><br><span class="line">    idlis = []</span><br><span class="line">    id = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> fh:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fh:</span><br><span class="line">            <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">'&gt;'</span>:</span><br><span class="line">                header = line[<span class="number">1</span>:].rstrip()</span><br><span class="line">                id = header.split()[<span class="number">0</span>]</span><br><span class="line">                idlis.append(id)</span><br><span class="line">                fas[id] = []</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                fas[id].append(line.rstrip())</span><br><span class="line">        <span class="keyword">for</span> id, seq <span class="keyword">in</span> fas.iteritems():</span><br><span class="line">            fas[id] = <span class="string">''</span>.join(seq)</span><br><span class="line">    <span class="keyword">return</span> fas, idlis</span><br><span class="line">ALN, IDlis = parseFasta(sys.argv[<span class="number">1</span>])</span><br><span class="line">outid = <span class="string">"-"</span>.join(IDlis)</span><br><span class="line">outseq = <span class="string">"\n"</span>.join([ALN[IDlis[<span class="number">0</span>]],ALN[IDlis[<span class="number">1</span>]]])</span><br><span class="line"><span class="keyword">print</span> <span class="string">"&gt;"</span> + outid</span><br><span class="line"><span class="keyword">print</span> outseq</span><br></pre></td></tr></table></figure></p>
<h3 id="step-4">Step 4:</h3>
<p>Calculate Ka,Ks</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Sequence        Method  Ka      Ks      Ka/Ks   P-Value(Fisher) Length  S-Sites N-Sites Fold-Sites(<span class="number">0</span>:<span class="number">2</span>:<span class="number">4</span>)       Substitutions   S-Substitutions   N-Substitutions Fold-S-Substitutions(<span class="number">0</span>:<span class="number">2</span>:<span class="number">4</span>)     Fold-N-Substitutions(<span class="number">0</span>:<span class="number">2</span>:<span class="number">4</span>)     Divergence-Time Substitution-Rate-Ratio(rTC:rAG:rTA:rCG:rTG:rCA/rCA)      GC(<span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>)       ML-Score        AICc    Akaike-Weight   Model</span><br><span class="line">ENSP00000004982-ENSMUSP00000039172      YN      <span class="number">0.0571682</span>       <span class="number">0.669484</span>        <span class="number">0.0853913</span>       <span class="number">6.30263e-22</span>     <span class="number">480</span>     <span class="number">150.779</span> <span class="number">329.221</span> NA82      <span class="number">64</span>      <span class="number">18</span>      NA      NA      <span class="number">0.249511</span>        <span class="number">6.00228</span>:<span class="number">6.00228</span>:<span class="number">1</span>:<span class="number">1</span>:<span class="number">1</span>:<span class="number">1</span> <span class="number">0.659465</span>(<span class="number">0.759259</span>:<span class="number">0.503086</span>:<span class="number">0.716049</span>)    NA      NA      NANA</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Genome</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>KaKs</tag>
        <tag>shell</tag>
        <tag>perl</tag>
      </tags>
  </entry>
  <entry>
    <title>python 实战-根据已知蛋白名称从基因组提取蛋白序列</title>
    <url>/posts/555c5d02/</url>
    <content><![CDATA[<h2 id="实战目的">实战目的</h2>
<hr />
<div class="note info no-icon"><p>Pkinase_maize_hmm.txt 是一个含有所需要提取蛋白名称（target name）的 txt 文件，Zea_mays.B73_RefGen_v4.pep.all.fa 文件是一个含有玉米基因组所有蛋白序列信息的 fa 文件，目的就是从 fa 文件提取我们所需蛋白名称的序列。</p>
</div>
<p><br> <a id="more"></a></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#                                                                            --- full sequence --- -------------- <span class="keyword">this</span> domain -------------   hmm coord   ali coord   env coord</span><br><span class="line"># target name        accession   tlen query name           accession   qlen   E-value  score  bias   #  of  c-Evalue  i-Evalue  score  bias  <span class="keyword">from</span>    to  <span class="keyword">from</span>    to  <span class="keyword">from</span>    to  acc description of target</span><br><span class="line">#------------------- ---------- ----- -------------------- ---------- ----- --------- ------ ----- --- --- --------- --------- ------ ----- ----- ----- ----- ----- ----- ----- ---- ---------------------</span><br><span class="line">Zm00001d052584_P001  -           <span class="number">1006</span> Pkinase              PF00069<span class="number">.25</span>   <span class="number">264</span>  <span class="number">1.1e-134</span>  <span class="number">450.7</span>   <span class="number">0.0</span>   <span class="number">1</span>   <span class="number">3</span>     <span class="number">3e-45</span>   <span class="number">7.5e-44</span>  <span class="number">152.9</span>   <span class="number">0.0</span>     <span class="number">2</span>   <span class="number">201</span>    <span class="number">38</span>   <span class="number">253</span>    <span class="number">37</span>   <span class="number">302</span> <span class="number">0.87</span> pep chromosome:B73_RefGen_v4:<span class="number">4</span>:<span class="number">193545827</span>:<span class="number">193587762</span>:<span class="number">1</span> gene:Zm00001d052584 transcript:Zm00001d052584_T001 gene_biotype:protein_coding transcript_biotype:protein_coding description:Protein kinase domain containing protein expressed</span><br><span class="line">Zm00001d052584_P001  -           <span class="number">1006</span> Pkinase              PF00069<span class="number">.25</span>   <span class="number">264</span>  <span class="number">1.1e-134</span>  <span class="number">450.7</span>   <span class="number">0.0</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">1.1e-42</span>   <span class="number">2.8e-41</span>  <span class="number">144.5</span>   <span class="number">0.0</span>     <span class="number">1</span>   <span class="number">260</span>   <span class="number">366</span>   <span class="number">642</span>   <span class="number">366</span>   <span class="number">644</span> <span class="number">0.90</span> pep chromosome:B73_RefGen_v4:<span class="number">4</span>:<span class="number">193545827</span>:<span class="number">193587762</span>:<span class="number">1</span> gene:Zm00001d052584 transcript:Zm00001d052584_T001 gene_biotype:protein_coding transcript_biotype:protein_coding description:Protein kinase domain containing protein expressed</span><br><span class="line">Zm00001d052584_P001  -           <span class="number">1006</span> Pkinase              PF00069<span class="number">.25</span>   <span class="number">264</span>  <span class="number">1.1e-134</span>  <span class="number">450.7</span>   <span class="number">0.0</span>   <span class="number">3</span>   <span class="number">3</span>   <span class="number">2.5e-44</span>   <span class="number">6.3e-43</span>  <span class="number">149.9</span>   <span class="number">0.0</span>     <span class="number">8</span>   <span class="number">260</span>   <span class="number">688</span>   <span class="number">965</span>   <span class="number">681</span>   <span class="number">967</span> <span class="number">0.86</span> pep chromosome:B73_RefGen_v4:<span class="number">4</span>:<span class="number">193545827</span>:<span class="number">193587762</span>:<span class="number">1</span> gene:Zm00001d052584 transcript:Zm00001d052584_T001 gene_biotype:protein_coding transcript_biotype:protein_coding description:Protein kinase domain containing protein expressed</span><br><span class="line">Zm00001d052584_P021  -           <span class="number">1006</span> Pkinase              PF00069<span class="number">.25</span>   <span class="number">264</span>  <span class="number">1.1e-134</span>  <span class="number">450.7</span>   <span class="number">0.0</span>   <span class="number">1</span>   <span class="number">3</span>     <span class="number">3e-45</span>   <span class="number">7.5e-44</span>  <span class="number">152.9</span>   <span class="number">0.0</span>     <span class="number">2</span>   <span class="number">201</span>    <span class="number">38</span>   <span class="number">253</span>    <span class="number">37</span>   <span class="number">302</span> <span class="number">0.87</span> pep chromosome:B73_RefGen_v4:<span class="number">4</span>:<span class="number">193545969</span>:<span class="number">193587645</span>:<span class="number">1</span> gene:Zm00001d052584 transcript:Zm00001d052584_T021 gene_biotype:protein_coding transcript_biotype:protein_coding description:Protein kinase domain containing protein expressed</span><br><span class="line">Zm00001d052584_P021  -           <span class="number">1006</span> Pkinase              PF00069<span class="number">.25</span>   <span class="number">264</span>  <span class="number">1.1e-134</span>  <span class="number">450.7</span>   <span class="number">0.0</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">1.1e-42</span>   <span class="number">2.8e-41</span>  <span class="number">144.5</span>   <span class="number">0.0</span>     <span class="number">1</span>   <span class="number">260</span>   <span class="number">366</span>   <span class="number">642</span>   <span class="number">366</span>   <span class="number">644</span> <span class="number">0.90</span> pep chromosome:B73_RefGen_v4:<span class="number">4</span>:<span class="number">193545969</span>:<span class="number">193587645</span>:<span class="number">1</span> gene:Zm00001d052584 transcript:Zm00001d052584_T021 gene_biotype:protein_coding transcript_biotype:protein_coding description:Protein kinase domain containing protein expressed</span><br><span class="line">Zm00001d052584_P021  -           <span class="number">1006</span> Pkinase              PF00069<span class="number">.25</span>   <span class="number">264</span>  <span class="number">1.1e-134</span>  <span class="number">450.7</span>   <span class="number">0.0</span>   <span class="number">3</span>   <span class="number">3</span>   <span class="number">2.5e-44</span>   <span class="number">6.3e-43</span>  <span class="number">149.9</span>   <span class="number">0.0</span>     <span class="number">8</span>   <span class="number">260</span>   <span class="number">688</span>   <span class="number">965</span>   <span class="number">681</span>   <span class="number">967</span> <span class="number">0.86</span> pep chromosome:B73_RefGen_v4:<span class="number">4</span>:<span class="number">193545969</span>:<span class="number">193587645</span>:<span class="number">1</span> gene:Zm00001d052584 transcript:Zm00001d052584_T021 gene_biotype:protein_coding transcript_biotype:protein_coding description:Protein kinase domain containing protein expressed</span><br><span class="line">Zm00001d052584_P023  -           <span class="number">1006</span> Pkinase              PF00069<span class="number">.25</span>   <span class="number">264</span>  <span class="number">1.1e-134</span>  <span class="number">450.7</span>   <span class="number">0.0</span>   <span class="number">1</span>   <span class="number">3</span>     <span class="number">3e-45</span>   <span class="number">7.5e-44</span>  <span class="number">152.9</span>   <span class="number">0.0</span>     <span class="number">2</span>   <span class="number">201</span>    <span class="number">38</span>   <span class="number">253</span>    <span class="number">37</span>   <span class="number">302</span> <span class="number">0.87</span> pep chromosome:B73_RefGen_v4:<span class="number">4</span>:<span class="number">193545969</span>:<span class="number">193587690</span>:<span class="number">1</span> gene:Zm00001d052584 transcript:Zm00001d052584_T023 gene_biotype:protein_coding transcript_biotype:protein_coding description:Protein kinase domain containing protein expressed</span><br><span class="line">Zm00001d052584_P023  -           <span class="number">1006</span> Pkinase              PF00069<span class="number">.25</span>   <span class="number">264</span>  <span class="number">1.1e-134</span>  <span class="number">450.7</span>   <span class="number">0.0</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">1.1e-42</span>   <span class="number">2.8e-41</span>  <span class="number">144.5</span>   <span class="number">0.0</span>     <span class="number">1</span>   <span class="number">260</span>   <span class="number">366</span>   <span class="number">642</span>   <span class="number">366</span>   <span class="number">644</span> <span class="number">0.90</span> pep chromosome:B73_RefGen_v4:<span class="number">4</span>:<span class="number">193545969</span>:<span class="number">193587690</span>:<span class="number">1</span> gene:Zm00001d052584 transcript:Zm00001d052584_T023 gene_biotype:protein_coding transcript_biotype:protein_coding description:Protein kinase domain containing protein expressed</span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">&gt;<span class="selector-tag">Zm00001d035916_P001</span> <span class="selector-tag">pep</span> <span class="selector-tag">chromosome</span><span class="selector-pseudo">:B73_RefGen_v4</span><span class="selector-pseudo">:6</span><span class="selector-pseudo">:60137069</span><span class="selector-pseudo">:60138570</span><span class="selector-pseudo">:1</span> <span class="selector-tag">gene</span><span class="selector-pseudo">:Zm00001d035916</span> <span class="selector-tag">transcript</span><span class="selector-pseudo">:Zm00001d035916_T001</span> <span class="selector-tag">gene_biotype</span><span class="selector-pseudo">:protein_coding</span> <span class="selector-tag">transcript_biotype</span><span class="selector-pseudo">:protein_coding</span> <span class="selector-tag">description</span>: <span class="selector-tag">UMP</span>/<span class="selector-tag">CMP</span> <span class="selector-tag">kinase1</span></span><br><span class="line"><span class="selector-tag">MPTVLCFYRANVYDHIFCLGGPGSGKGTQCSKIVRHFGFTHLSAGDLLRQQVQSDTEHGA</span></span><br><span class="line"><span class="selector-tag">MIKNLMHEGKLVPSDIIVRLLLTAMLQSGNDRFLVDGFPRNEENRRAYESVIGIEPELVL</span></span><br><span class="line"><span class="selector-tag">FIDCPREELERRILHRDQGRDDDNVDTIRKRFQVFHDSTLPVVLYYDRMGKVRRVDGAKS</span></span><br><span class="line"><span class="selector-tag">ADAVFDDVKAIFTQLLTTQVHSLTHIYLPFFFPIDCSLLIKP</span></span><br><span class="line">&gt;<span class="selector-tag">Zm00001d048284_P001</span> <span class="selector-tag">pep</span> <span class="selector-tag">chromosome</span><span class="selector-pseudo">:B73_RefGen_v4</span><span class="selector-pseudo">:9</span><span class="selector-pseudo">:153880862</span><span class="selector-pseudo">:153883850</span><span class="selector-pseudo">:-1</span> <span class="selector-tag">gene</span><span class="selector-pseudo">:Zm00001d048284</span> <span class="selector-tag">transcript</span><span class="selector-pseudo">:Zm00001d048284_T001</span> <span class="selector-tag">gene_biotype</span><span class="selector-pseudo">:protein_coding</span> <span class="selector-tag">transcript_biotype</span><span class="selector-pseudo">:protein_coding</span> <span class="selector-tag">description</span><span class="selector-pseudo">:YlmG</span> <span class="selector-tag">homolog</span> <span class="selector-tag">protein</span> <span class="selector-tag">2</span> <span class="selector-tag">chloroplastic</span></span><br><span class="line"><span class="selector-tag">MAASSADPAQHHASSRPPLLLAVRHLPFPGVPRTRTFPVPGPDVLAPLARRLEELASAAA</span></span><br><span class="line"><span class="selector-tag">AHPLLKPLFAAHSHLSSFSQRSRREPTPLWFDGASHEQGRRRLVAARRATVLSSGELCFA</span></span><br><span class="line"><span class="selector-tag">AVLGDSVAGTVVASGINNFLNLYNTVLVVRLVLTWFPNTPPAIVAPLSTILAFLVLNAFT</span></span><br><span class="line"><span class="selector-tag">STAAALPAELPSCSATAQHHQRTAVSPCSAPHEATLSQRKWMRRMRSQKPQGDDGDH</span></span><br><span class="line">&gt;<span class="selector-tag">Zm00001d048284_P002</span> <span class="selector-tag">pep</span> <span class="selector-tag">chromosome</span><span class="selector-pseudo">:B73_RefGen_v4</span><span class="selector-pseudo">:9</span><span class="selector-pseudo">:153880862</span><span class="selector-pseudo">:153883850</span><span class="selector-pseudo">:-1</span> <span class="selector-tag">gene</span><span class="selector-pseudo">:Zm00001d048284</span> <span class="selector-tag">transcript</span><span class="selector-pseudo">:Zm00001d048284_T002</span> <span class="selector-tag">gene_biotype</span><span class="selector-pseudo">:protein_coding</span> <span class="selector-tag">transcript_biotype</span><span class="selector-pseudo">:protein_coding</span> <span class="selector-tag">description</span><span class="selector-pseudo">:YlmG</span> <span class="selector-tag">homolog</span> <span class="selector-tag">protein</span> <span class="selector-tag">2</span> <span class="selector-tag">chloroplastic</span></span><br><span class="line"><span class="selector-tag">MAASSADPAQHHASSRPPLLLAVRHLPFPGVPRTRTFPVPGPDVLAPLARRLEELASAAA</span></span><br><span class="line"><span class="selector-tag">AHPLLKPLFAAHSHLSSFSQHDTRFPRPQRLHQHGRRASRGAAKLLGNGAASPEDCCLTL</span></span><br><span class="line"><span class="selector-tag">LGAA</span></span><br></pre></td></tr></table></figure>
<h2 id="思-路">思 路</h2>
<hr />
<p>提取 Pkinase_maize_hmm.txt 文件中的蛋白名称（去重）<br> 从 fa 文件提取对应蛋白的序列</p>
<h2 id="步-骤">步 骤</h2>
<hr />
<h3 id="提取-pkinase_maize_hmm.txt-文件中的蛋白名称">1. 提取 Pkinase_maize_hmm.txt 文件中的蛋白名称</h3>
<p>方法1：循环遍历去除重复项后写入到一个列表 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gene_list = [] <span class="comment">#设置空列表用于存储蛋白名称</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'D:\data\Pkinase_maize_hmm.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> a:  <span class="comment">#读取含有蛋白名称的文件</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a: <span class="comment">#for循环逐行遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> i.startswith(<span class="string">'#'</span>): <span class="comment">#跳过文件中的注释行</span></span><br><span class="line">            gene_id = i.split(<span class="string">' '</span>)[<span class="number">0</span>] <span class="comment">#按空格将每行信息分开并选取第一列蛋白名称</span></span><br><span class="line">            <span class="keyword">if</span> gene_id <span class="keyword">not</span> <span class="keyword">in</span> gene_list: <span class="comment">#如果临时列表中没有当前元素则追加</span></span><br><span class="line">                gene_list.append(gene_id) <span class="comment">#append函数用于将符合条件的蛋白名称添加到列表</span></span><br><span class="line">print(len(gene_list)) <span class="comment">#查看蛋白数目</span></span><br></pre></td></tr></table></figure></p>
<p>方法2：转换为集合(set)再转换为列表(list) <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gene_list1 = []</span><br><span class="line">gene_list2 = []</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'D:\data\Pkinase_maize_hmm.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> a:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> i.startswith(<span class="string">'#'</span>):</span><br><span class="line">            gene_list1.append(i.split(<span class="string">' '</span>)[<span class="number">0</span>])</span><br><span class="line">            gene_list2 = list(set(gene_list1))</span><br><span class="line">print(len(gene_list2))</span><br></pre></td></tr></table></figure></p>
<p>判断两种方法结果是否一致： <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment">#把列表转换为集合,利用集合操作符求出交集,然后再转换回列表类型</span></span><br><span class="line"><span class="builtin-name">print</span>(len(list(<span class="builtin-name">set</span>(gene_list) &amp; <span class="builtin-name">set</span>(gene_list2))))</span><br></pre></td></tr></table></figure></p>
<h3 id="从-fa-文件提取对应蛋白的序列">2. 从 fa 文件提取对应蛋白的序列</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">final_seq = &#123;&#125; <span class="comment">#设置一个空字典用于存放结果</span></span><br><span class="line">parse_check = <span class="literal">False</span> <span class="comment">#设置变量用于判断读取的行是否为所需蛋白名称所在行，首先设为flase</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'D:\yanglab_data\bioinformation_file\protein\blastdb\Zea_mays.B73_RefGen_v4.pep.all.fa'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> a:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> i.startswith(<span class="string">'&gt;'</span>): <span class="comment">#判断是否以&gt;开头</span></span><br><span class="line">            seq_ID = i.split(<span class="string">' '</span>)[<span class="number">0</span>][<span class="number">1</span>:] <span class="comment">#读取fa文件的蛋白名</span></span><br><span class="line">            <span class="keyword">if</span> seq_ID <span class="keyword">in</span> gene_list: <span class="comment">#判断fa文件中的蛋白名称是否在所需蛋白列表中</span></span><br><span class="line">                parse_check = <span class="literal">True</span> <span class="comment">#如果包含在gene_list中则将parse_check重新赋值为True</span></span><br><span class="line">                seq=[] <span class="comment">#设置空列表用于储存序列</span></span><br><span class="line">                final_seq[seq_ID] = seq <span class="comment">#设置字典中key对应的value为列表形式</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                parse_check = <span class="literal">False</span> <span class="comment">#如果fa的蛋白不在gene_list中，parse仍为false</span></span><br><span class="line">        <span class="keyword">elif</span> parse_check == <span class="literal">True</span>: <span class="comment">#如果parse为true（即fa蛋白在gene_list中）</span></span><br><span class="line">            seq_part= i.split(<span class="string">'\n'</span>)[<span class="number">0</span>] <span class="comment">#将序列添加到序列列表seq中</span></span><br><span class="line">            seq.append(seq_part)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将字典中的结果输出到results.fa中</span></span><br><span class="line">outfile = open(<span class="string">'results.fa'</span>, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> id <span class="keyword">in</span> final_seq:</span><br><span class="line">    outfile.write(<span class="string">'&gt;%s\n'</span> % id) <span class="comment">#设置字符串格式提取id信息（即蛋白名称）</span></span><br><span class="line">    sequence = final_seq[id] <span class="comment">#获取id对应的序列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sequence:</span><br><span class="line">        outfile.write(<span class="string">'%s'</span> % (i)) <span class="comment">#获取序列信息并设置格式输出</span></span><br><span class="line">    outfile.write(<span class="string">'\n'</span>)</span><br><span class="line">outfile.close()</span><br></pre></td></tr></table></figure>
<p>判断结果是否准确 <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span> = []</span><br><span class="line">with <span class="keyword">open</span>(r<span class="string">'D:\data\results.fa'</span>) <span class="keyword">as</span> <span class="variable">a:</span></span><br><span class="line">    <span class="keyword">for</span> i in <span class="variable">a:</span></span><br><span class="line">        <span class="keyword">if</span> i.startswith(<span class="string">'&gt;'</span>):</span><br><span class="line">            <span class="keyword">file</span>.<span class="keyword">append</span>(i.<span class="keyword">split</span>()[<span class="number">0</span>][<span class="number">1</span>:])</span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">len</span>(<span class="keyword">file</span>))</span><br><span class="line"><span class="keyword">print</span>(<span class="built_in">len</span>(<span class="keyword">list</span>(<span class="keyword">set</span>(gene_list) &amp; <span class="keyword">set</span>(<span class="keyword">file</span>))))</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Data_processing</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SnapATAC软件分析单细胞ATAC-seq数据（一）：SnapATAC简介与安装</title>
    <url>/posts/ac829b5/</url>
    <content><![CDATA[<h2 id="snapatac简介">SnapATAC简介</h2>
<hr />
<div class="note info no-icon"><p><strong>SnapATAC</strong> (Single Nucleus Analysis Pipeline for ATAC-seq) 是一个能够快速、准确和全面分析单细胞ATAC-seq数据的R包，它可以对单细胞ATAC-seq数据进行常规的数据降维、聚类和批次校正分析，鉴定远端调控元件并预测其调控的靶基因，调用chromVAR软件进行motif分析，同时还可以将scRNA-seq和scATAC-seq数据进行整合分析等。</p>
</div>
<p><br></p>
<a id="more"></a>
<h2 id="snapatac软件安装">SnapATAC软件安装</h2>
<hr />
<h3 id="requirements">Requirements</h3>
<ul>
<li>Linux/Unix</li>
<li>Python (&gt;= 2.7 &amp; &lt; 3.0) (SnapTools) (highly recommanded for 2.7);</li>
<li>R (&gt;= 3.4.0 &amp; &lt; 3.6.0) (SnapATAC) (3.6 does not work for rhdf5 package);<br></li>
</ul>
<h3 id="pre-print">Pre-print</h3>
<p>Rongxin Fang, Sebastian Preissl, Xiaomeng Hou, Jacinta Lucero, Xinxin Wang, Amir Motamedi, Andrew K. Shiau, Eran A. Mukamel, Yanxiao Zhang, M. Margarita Behrens, Joseph Ecker, Bing Ren. <strong>Fast and Accurate Clustering of Single Cell Epigenomes Reveals Cis-Regulatory Elements in Rare Cell Types.</strong> bioRxiv 615179; doi: <span class="exturl" data-url="aHR0cHM6Ly9kb2kub3JnLzEwLjExMDEvNjE1MTc5">https://doi.org/10.1101/615179<i class="fa fa-external-link-alt"></i></span><br></p>
<h3 id="installation">Installation</h3>
<p>SnapATAC软件主要由以下两个组件组成：<code>Snaptools</code>和<code>SnapATAC</code>.</p>
<ul>
<li><mark class="label default"><font color=c52950>SnapTools</font></mark>
一个用于预处理和处理snap格式文件的python模块。</li>
<li><mark class="label default"><font color=c52950>SnapATAC</font></mark>
一个用于数据聚类、注释、motif发现和下游分析的R包。</li>
</ul>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Install snaptools from PyPI. </span></span><br><span class="line"><span class="meta"># NOTE: Please use python 2.7 if possible.</span></span><br><span class="line"><span class="meta"># 使用pip安装snaptools模块</span></span><br><span class="line">pip install snaptools</span><br><span class="line"></span><br><span class="line"><span class="meta"># Install SnapATAC R pakcage (development version).</span></span><br><span class="line"><span class="meta"># 安装一些依赖R包</span></span><br><span class="line">install.packages(c(<span class="string">'raster'</span>,<span class="string">'bigmemory'</span>,<span class="string">'doSNOW'</span>,<span class="string">'plot3D'</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta"># 使用devtools安装SnapATAC包</span></span><br><span class="line">library(devtools)</span><br><span class="line">install_github(<span class="string">"r3fang/SnapATAC"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="snapatac常见问题汇总">SnapATAC常见问题汇总</h2>
<hr />
<h3 id="what-is-a-snap-file">1）What is a snap file?</h3>
<p>snap (Single-Nucleus Accessibility Profiles)格式文件是一个层级结构的hdf5文件，它可以用来存储single nucleus ATAC-seq数据集。该文件（version 4）主要由以下几个部分组成：header (HD), cell-by-bin accessibility matrix (AM), cell-by-peak matrix (PM), cell-by-gene matrix (GM), barcode (BD) and fragment (FM).</p>
<ul>
<li>HD session: 包含snap文件的版本、创建日期、比对信息和参考基因组信息。</li>
<li>BD session: 包含所有unique细胞的barcodes和相应的meta data信息。</li>
<li>AM session: 包含不同分辨率（bin size）下的cell-by-bin数据矩阵。</li>
<li>PM session: 包含cell-by-peak的计数矩阵和cell-by-gene的计数矩阵。</li>
<li>FM session: 包含每个细胞中可用的所有frangments片段信息。</li>
</ul>
<h3 id="how-to-create-a-snap-file-from-fastq-file">2）How to create a snap file from fastq file?</h3>
<p>Step 1. Barcode demultiplexing.</p>
<p>首先，我们将barcode信息以"@" + "barcode" + ":" + "read_name"的格式添加到每条read的开头，用以拆分FASTQ文件。 下面是一个用于拆分fastq文件的示例，我们可以通过awk或python脚本轻松实现。 <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"># 下载示例数据</span><br><span class="line"><span class="selector-tag">wget</span> <span class="selector-tag">http</span>:<span class="comment">//renlab.sdsc.edu/r3fang/share/Fang_2019/MOs_snATAC/fastq/CEMBA180306_2B.demultiplexed.R1.fastq.gz</span></span><br><span class="line"><span class="selector-tag">wget</span> <span class="selector-tag">http</span>:<span class="comment">//renlab.sdsc.edu/r3fang/share/Fang_2019/MOs_snATAC/fastq/CEMBA180306_2B.demultiplexed.R2.fastq.gz</span></span><br><span class="line"><span class="selector-tag">wget</span> <span class="selector-tag">http</span>:<span class="comment">//renlab.sdsc.edu/r3fang/share/Fang_2019/MOs_snATAC/peaks/all_peak.bed</span></span><br><span class="line"><span class="selector-tag">wget</span> <span class="selector-tag">http</span>:<span class="comment">//renlab.sdsc.edu/r3fang/share/Fang_2019/MOs_snATAC/mm10.blacklist.bed.gz</span></span><br><span class="line"><span class="selector-tag">wget</span> <span class="selector-tag">http</span>:<span class="comment">//renlab.sdsc.edu/r3fang/share/Fang_2019/MOs_snATAC/genes/gencode.vM16.gene.bed</span></span><br><span class="line"><span class="selector-tag">wget</span> <span class="selector-tag">http</span>:<span class="comment">//hgdownload.cse.ucsc.edu/goldenPath/mm10/bigZips/mm10.chrom.sizes</span></span><br><span class="line"><span class="selector-tag">wget</span> <span class="selector-tag">http</span>:<span class="comment">//renlab.sdsc.edu/r3fang/share/Fang_2019/MOs_snATAC/genome/mm10.fa</span></span><br><span class="line"></span><br><span class="line"># 查看<span class="selector-tag">fastq</span>文件</span><br><span class="line"><span class="selector-tag">zcat</span> <span class="selector-tag">CEMBA180306_2B</span><span class="selector-class">.demultiplexed</span><span class="selector-class">.R1</span><span class="selector-class">.fastq</span><span class="selector-class">.gz</span> | <span class="selector-tag">head</span> </span><br><span class="line">@<span class="selector-tag">AGACGGAGACGAATCTAGGCTGGTTGCCTTAC</span><span class="selector-pseudo">:7001113</span><span class="selector-pseudo">:920</span><span class="selector-pseudo">:HJ55CBCX2</span><span class="selector-pseudo">:1</span><span class="selector-pseudo">:1108</span><span class="selector-pseudo">:1121</span><span class="selector-pseudo">:1892</span> <span class="selector-tag">1</span><span class="selector-pseudo">:N</span><span class="selector-pseudo">:0</span><span class="selector-pseudo">:0</span></span><br><span class="line"><span class="selector-tag">ATCCTGGCATGAAAGGATTTTTTTTTTAGAAAATGAAATATATTTTAAAG</span></span><br><span class="line">+</span><br><span class="line"><span class="selector-tag">DDDDDIIIIHIIGHHHIIIHIIIIIIHHIIIIIIIIIIIIIIIIIIIIII</span></span><br></pre></td></tr></table></figure> Step 2. Index reference genome (snaptools).</p>
<p>接下来，我们将对参考基因组构建索引用于后续的比对分析，这里我们展示了如何使用BWA来构建参考基因组的索引。用户可以通过<mark class="label default"><font color=c52950> --aligner</font></mark>参数指定要使用的比对软件，目前snaptools可以支持bwa, bowtie2和minimap2比对软件。同时，我们还需要指定比对软件所在文件夹的路径，例如，如果bwa安装在/opt/biotools/bwa/bin/bwa下，我们需要指定--path-to-aligner=/opt/biotools/bwa/bin/</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看bwa软件所在的路径</span></span><br><span class="line">which bwa</span><br><span class="line">/opt/biotools/bwa/bin/bwa </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用snaptools构建参考基因组索引</span></span><br><span class="line">snaptools index-genome  \</span><br><span class="line">    <span class="attribute">--input-fasta</span>=mm10.fa  \</span><br><span class="line">    <span class="attribute">--output-prefix</span>=mm10  \</span><br><span class="line">    <span class="attribute">--aligner</span>=bwa  \</span><br><span class="line">    <span class="attribute">--path-to-aligner</span>=/opt/biotools/bwa/bin/  \</span><br><span class="line">    <span class="attribute">--num-threads</span>=5</span><br></pre></td></tr></table></figure>
<p>Step 3. Alignment (snaptools).</p>
<p>构建好参考基因组索引后，我们使用snaptools将拆分后的FASTQ reads序列比对到相应的参考基因组上。比对后，将比对好的bam文件按reads名称进行排序。我们还可以通过设置--num-threads参数指定多个CPU加快比对的速度。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">snaptools align-paired-end  \</span><br><span class="line">    <span class="attribute">--input-reference</span>=mm10.fa  \</span><br><span class="line">    <span class="attribute">--input-fastq1</span>=CEMBA180306_2B.demultiplexed.R1.fastq.gz  \</span><br><span class="line">    <span class="attribute">--input-fastq2</span>=CEMBA180306_2B.demultiplexed.R2.fastq.gz  \</span><br><span class="line">    <span class="attribute">--output-bam</span>=CEMBA180306_2B.bam  \</span><br><span class="line">    <span class="attribute">--aligner</span>=bwa  \</span><br><span class="line">    <span class="attribute">--path-to-aligner</span>=/opt/biotools/bwa/bin/  \</span><br><span class="line">    <span class="attribute">--read-fastq-command</span>=zcat  \</span><br><span class="line">    <span class="attribute">--min-cov</span>=0  \</span><br><span class="line">    <span class="attribute">--num-threads</span>=5  \</span><br><span class="line">    <span class="attribute">--if-sort</span>=<span class="literal">True</span>  \</span><br><span class="line">    <span class="attribute">--tmp-folder</span>=./  \</span><br><span class="line">    <span class="attribute">--overwrite</span>=<span class="literal">TRUE</span></span><br></pre></td></tr></table></figure>
<p>Step 4. Pre-processing (snaptools).</p>
<p>比对完之后，我们将比对好的双端reads转换为fragments片段，并查看每个 fragment片段的以下属性:<br> 1)比对质量评分MAPQ;<br> 2)比对上的reads两端是否按比对的flag值正确配对;<br> 3)fragments片段的长度：<br> 我们根据以下条件进行过滤筛选，只保留满足条件的fragments片段;<br> 1)两端正确配对的fragments片段；<br> 2)MAPQ值大于30的fragments片段(-min-mapq);<br> 3)长度小于1000bp的fragments片段 (-max-flen)。<br></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取参考基因染色体长度信息</span></span><br><span class="line">fetchChromSizes mm10.fa &gt; mm10.chrom.sizes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用snaptools进行数据预处理，生成snap格式文件</span></span><br><span class="line">snaptools snap-pre  \</span><br><span class="line">    <span class="attribute">--input-file</span>=CEMBA180306_2B.bam  \</span><br><span class="line">    <span class="attribute">--output-snap</span>=CEMBA180306_2B.snap  \</span><br><span class="line">    <span class="attribute">--genome-name</span>=mm10  \</span><br><span class="line">    <span class="attribute">--genome-size</span>=mm10.chrom.sizes  \</span><br><span class="line">    <span class="attribute">--min-mapq</span>=30  \</span><br><span class="line">    <span class="attribute">--min-flen</span>=0  \</span><br><span class="line">    <span class="attribute">--max-flen</span>=1000  \</span><br><span class="line">    <span class="attribute">--keep-chrm</span>=<span class="literal">TRUE</span>  \</span><br><span class="line">    <span class="attribute">--keep-single</span>=<span class="literal">FALSE</span>  \</span><br><span class="line">    <span class="attribute">--keep-secondary</span>=<span class="literal">FALSE</span>  \</span><br><span class="line">    <span class="attribute">--overwrite</span>=<span class="literal">True</span>  \</span><br><span class="line">    <span class="attribute">--min-cov</span>=100  \</span><br><span class="line">    <span class="attribute">--verbose</span>=<span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>Step 5. Cell-by-bin matrix (snaptools).</p>
<p>最后，我们使用snap文件创建不同分辨率下的cell-by-bin矩阵文件。在下面的示例中，我们分别创建了1,000、5,000和10,000 bin size下的三个cell-by-bin矩阵，并将所有的矩阵都存储在cemba180306_2B.snap文件中。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用snaptools创建cell-by-bin矩阵</span></span><br><span class="line">snaptools snap-<span class="built_in">add</span>-bmat    \</span><br><span class="line">    <span class="comment">--snap-file=CEMBA180306_2B.snap \</span></span><br><span class="line">    <span class="comment">--bin-size-list 1000 5000 10000 \</span></span><br><span class="line">    <span class="comment">--verbose=True</span></span><br></pre></td></tr></table></figure>
<h3 id="how-to-create-snap-file-from-10x-dataset">3）How to create snap file from 10X dataset?</h3>
<p>Case 1<br> <img src="https://camo.githubusercontent.com/fe8c50206e0c567a1691f11ad3e9ea5482a0f9aa/68747470733a2f2f737570706f72742e31307867656e6f6d6963732e636f6d2f696d672f63656c6c72616e6765722d617461632d776f726b666c6f77732f6d6b66617374715f322e706e67" /> 1）首先，运行cellranger-atac mkfastq生成拆库后的fastq文件；<br> 2）接下来，对于每个测序文库，识别相应的测序文件，其中R1和R3是测序的<br>reads，I1是16bp i5 (10x Barcode), R2是i7 (sample index)。<br> 3）最后，使用snaptools提供的dex-fastq子程序，将10X barcode信息添加到reads的名称中。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">snaptools dex-fastq \</span><br><span class="line">    --input-fastq=<span class="module-access"><span class="module"><span class="identifier">Library1_1_L001_R1_001</span>.</span></span>fastq.gz \</span><br><span class="line">    --output-fastq=<span class="module-access"><span class="module"><span class="identifier">Library1_1_L001_R1_001</span>.</span></span>dex.fastq.gz \ </span><br><span class="line">    --index-fastq-<span class="built_in">list</span> <span class="module-access"><span class="module"><span class="identifier">Library1_1_L001_R2_001</span>.</span></span>fastq.gz</span><br><span class="line"></span><br><span class="line">snaptools dex-fastq \</span><br><span class="line">    --input-fastq=<span class="module-access"><span class="module"><span class="identifier">Library1_1_L001_R3_001</span>.</span></span>fastq.gz \</span><br><span class="line">    --output-fastq=<span class="module-access"><span class="module"><span class="identifier">Library1_1_L001_R3_001</span>.</span></span>dex.fastq.gz \ </span><br><span class="line">    --index-fastq-<span class="built_in">list</span> <span class="module-access"><span class="module"><span class="identifier">Library1_1_L001_R2_001</span>.</span></span>fastq.gz</span><br><span class="line"></span><br><span class="line">snaptools dex-fastq \</span><br><span class="line">    --input-fastq=<span class="module-access"><span class="module"><span class="identifier">Library1_2_L001_R1_001</span>.</span></span>fastq.gz \</span><br><span class="line">    --output-fastq=<span class="module-access"><span class="module"><span class="identifier">Library1_2_L001_R1_001</span>.</span></span>dex.fastq.gz \ </span><br><span class="line">    --index-fastq-<span class="built_in">list</span> <span class="module-access"><span class="module"><span class="identifier">Library1_2_L001_R2_001</span>.</span></span>fastq.gz</span><br><span class="line"></span><br><span class="line">snaptools dex-fastq \</span><br><span class="line">    --input-fastq=<span class="module-access"><span class="module"><span class="identifier">Library1_2_L001_R3_001</span>.</span></span>fastq.gz \</span><br><span class="line">    --output-fastq=<span class="module-access"><span class="module"><span class="identifier">Library1_2_L001_R3_001</span>.</span></span>dex.fastq.gz \ </span><br><span class="line">    --index-fastq-<span class="built_in">list</span> <span class="module-access"><span class="module"><span class="identifier">Library1_2_L001_R2_001</span>.</span></span>fastq.gz</span><br><span class="line"></span><br><span class="line"># combine these two library</span><br><span class="line">cat <span class="module-access"><span class="module"><span class="identifier">Library1_1_L001_R1_001</span>.</span></span>fastq.gz <span class="module-access"><span class="module"><span class="identifier">Library1_2_L001_R1_001</span>.</span></span>fastq.gz &gt; <span class="module-access"><span class="module"><span class="identifier">Library1_L001_R1_001</span>.</span></span>fastq.gz</span><br><span class="line"></span><br><span class="line">cat <span class="module-access"><span class="module"><span class="identifier">Library1_1_L001_R3_001</span>.</span></span>fastq.gz <span class="module-access"><span class="module"><span class="identifier">Library1_2_L001_R3_001</span>.</span></span>fastq.gz &gt; <span class="module-access"><span class="module"><span class="identifier">Library1_L001_R3_001</span>.</span></span>fastq.gz</span><br></pre></td></tr></table></figure>
<p>Case 2 <br> <img src="https://camo.githubusercontent.com/65e69e4036b9cbcd7ced5091a7f8ce22dd11a29b/68747470733a2f2f737570706f72742e31307867656e6f6d6963732e636f6d2f696d672f63656c6c72616e6765722d617461632d776f726b666c6f77732f6d6b66617374715f312e706e67" /> 在本示例中，我们有两个10x的测序文库(每个文库都通过单独的Chromium chip channel进行处理)。请注意，在运行完<mark class="label default"><font color=c52950>cellranger-atac mkfastq</font></mark>拆分数据之后，我们对每个文库进行单独的<mark class="label default"><font color=c52950>cellranger-atac count</font></mark>处理。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">snaptools dex-fastq \</span><br><span class="line">    --input-fastq=<span class="module-access"><span class="module"><span class="identifier">Library1_S1_L001_R1_001</span>.</span></span>fastq.gz \</span><br><span class="line">    --output-fastq=<span class="module-access"><span class="module"><span class="identifier">Library1_S1_L001_R1_001</span>.</span></span>dex.fastq.gz \ </span><br><span class="line">    --index-fastq-<span class="built_in">list</span> <span class="module-access"><span class="module"><span class="identifier">Library1_S1_L001_R2_001</span>.</span></span>fastq.gz</span><br><span class="line"></span><br><span class="line">snaptools dex-fastq \</span><br><span class="line">    --input-fastq=<span class="module-access"><span class="module"><span class="identifier">Library1_S1_L001_R3_001</span>.</span></span>fastq.gz \</span><br><span class="line">    --output-fastq=<span class="module-access"><span class="module"><span class="identifier">Library1_S1_L001_R3_001</span>.</span></span>dex.fastq.gz \ </span><br><span class="line">    --index-fastq-<span class="built_in">list</span> <span class="module-access"><span class="module"><span class="identifier">Library1_S1_L001_R2_001</span>.</span></span>fastq.gz</span><br></pre></td></tr></table></figure>
<h3 id="can-i-run-snapatac-with-cellranger-outcome">4）Can I run SnapATAC with CellRanger outcome?</h3>
<p>Yes. There are two entry points</p>
<p>（1）use the position sorted bam file (recommanded).</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># 查看比对的bam文件信息</span><br><span class="line">samtools view atac_v1_adult_brain_fresh_5k_possorted_bam.bam</span><br><span class="line">A00519:<span class="number">218</span>:HJYFLDSXX:<span class="number">2</span>:<span class="number">1216</span>:<span class="number">26458</span>:<span class="number">34976</span>    <span class="number">99</span>  chr1    <span class="number">3000138</span> <span class="number">60</span>  <span class="number">50</span>M =   <span class="number">3000474</span> <span class="number">385</span> TGATGACTGCCTCTATTTCTTTAGGGGAAATGGGACTTTTAGTCCATGAA  FFFFFFFFFFFFFFFF,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  NM:i:<span class="number">0</span>  MD:Z:<span class="number">50</span> MC:Z:<span class="number">49</span>M    AS:i:<span class="number">50</span> XS:i:<span class="number">37</span> CR:Z:GGTTGCGAGCCGCAAA   CY:Z:FFFFFFFFFFFFFFFF   CB:Z:GGTTGCGAGCCGCAAA<span class="number">-1</span> BC:Z:AACGGTCA   QT:Z:FFFFFFFFGP:i:<span class="number">3000137</span>   MP:i:<span class="number">3000522</span>    MQ:i:<span class="number">40</span> RG:Z:atac_v1_adult_brain_fresh_5k:MissingLibrary:<span class="number">1</span>:HJYFLDSXX:<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>在比对的read名称前添加barcode信息<br> The cell barcode is embedded in the tag CB:Z:GGTTGCGAGCCGCAAA-1, you can modify the bam file by add the cell barcode GGTTGCGAGCCGCAAA-1 to the beginning of read</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># extract the header file</span><br><span class="line">samtools view atac_v1_adult_brain_fresh_5k_possorted_bam.bam -H &gt; atac_v1_adult_brain_fresh_5k_possorted.header.sam</span><br><span class="line"></span><br><span class="line"># create a bam file with the barcode embedded <span class="built_in">int</span>o the read name</span><br><span class="line">cat &lt;( cat atac_v1_adult_brain_fresh_5k_possorted.header.sam ) \</span><br><span class="line">&lt;( samtools view atac_v1_adult_brain_fresh_5k_possorted_bam.bam | awk <span class="string">'&#123;for (i=12; i&lt;=NF; ++i) &#123; if ($i ~ "^CB:Z:")&#123; td[substr($i,1,2)] = substr($i,6,length($i)-5); &#125; &#125;; printf "%s:%s\n", td["CB"], $0 &#125;'</span> ) \</span><br><span class="line">| samtools view -bS - &gt; atac_v1_adult_brain_fresh_5k_possorted.snap.bam</span><br><span class="line"></span><br><span class="line"># 查看添加好barcode信息的bam文件</span><br><span class="line">samtools view atac_v1_adult_brain_fresh_5k_possorted.snap.bam | cut -f <span class="number">1</span> | head </span><br><span class="line">GGTTGCGAGCCGCAAA<span class="number">-1</span>:A00519:<span class="number">218</span>:HJYFLDSXX:<span class="number">2</span>:<span class="number">1216</span>:<span class="number">26458</span>:<span class="number">34976</span></span><br><span class="line">GGTTGCGAGCCGCAAA<span class="number">-1</span>:A00519:<span class="number">218</span>:HJYFLDSXX:<span class="number">2</span>:<span class="number">2256</span>:<span class="number">23194</span>:<span class="number">13823</span></span><br><span class="line">GGTTGCGAGCCGCAAA<span class="number">-1</span>:A00519:<span class="number">218</span>:HJYFLDSXX:<span class="number">2</span>:<span class="number">2546</span>:<span class="number">5258</span>:<span class="number">31955</span></span><br><span class="line">CTCAGCTAGTGTCACT<span class="number">-1</span>:A00519:<span class="number">218</span>:HJYFLDSXX:<span class="number">1</span>:<span class="number">2428</span>:<span class="number">8648</span>:<span class="number">18349</span></span><br><span class="line">CTCAGCTAGTGTCACT<span class="number">-1</span>:A00519:<span class="number">218</span>:HJYFLDSXX:<span class="number">1</span>:<span class="number">2428</span>:<span class="number">8648</span>:<span class="number">18349</span></span><br><span class="line">GAAGTCTGTAACACTC<span class="number">-1</span>:A00519:<span class="number">218</span>:HJYFLDSXX:<span class="number">3</span>:<span class="number">2546</span>:<span class="number">14968</span>:<span class="number">2331</span></span><br><span class="line">GAAGTCTGTAACACTC<span class="number">-1</span>:A00519:<span class="number">218</span>:HJYFLDSXX:<span class="number">3</span>:<span class="number">2546</span>:<span class="number">14705</span>:<span class="number">2628</span></span><br><span class="line">GGTTGCGAGCCGCAAA<span class="number">-1</span>:A00519:<span class="number">218</span>:HJYFLDSXX:<span class="number">2</span>:<span class="number">1216</span>:<span class="number">26458</span>:<span class="number">34976</span></span><br><span class="line">GGTTGCGAGCCGCAAA<span class="number">-1</span>:A00519:<span class="number">218</span>:HJYFLDSXX:<span class="number">2</span>:<span class="number">2256</span>:<span class="number">23194</span>:<span class="number">13823</span></span><br><span class="line">GGTTGCGAGCCGCAAA<span class="number">-1</span>:A00519:<span class="number">218</span>:HJYFLDSXX:<span class="number">2</span>:<span class="number">2546</span>:<span class="number">5258</span>:<span class="number">31955</span></span><br></pre></td></tr></table></figure>
<p>对bam文件按read的名称进行排序<br> Then sort the bam file by read name: <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">samtools sort -n -@ <span class="number">10</span> -m <span class="number">1</span>G atac_v1_adult_brain_fresh_5k_possorted<span class="selector-class">.snap</span><span class="selector-class">.bam</span> -o atac_v1_adult_brain_fresh_5k<span class="selector-class">.snap</span><span class="selector-class">.nsrt</span>.bam</span><br></pre></td></tr></table></figure></p>
<p>使用snaptools进行数据预处理生成snap文件<br> Then generate the snap file <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">snaptools snap-pre  \</span><br><span class="line">    <span class="attribute">--input-file</span>=atac_v1_adult_brain_fresh_5k.snap.nsrt.bam  \</span><br><span class="line">    <span class="attribute">--output-snap</span>=atac_v1_adult_brain_fresh_5k.snap  \</span><br><span class="line">    <span class="attribute">--genome-name</span>=mm10  \</span><br><span class="line">    <span class="attribute">--genome-size</span>=mm10.chrom.sizes  \</span><br><span class="line">    <span class="attribute">--min-mapq</span>=30  \</span><br><span class="line">    <span class="attribute">--min-flen</span>=50  \</span><br><span class="line">    <span class="attribute">--max-flen</span>=1000  \</span><br><span class="line">    <span class="attribute">--keep-chrm</span>=<span class="literal">TRUE</span>  \</span><br><span class="line">    <span class="attribute">--keep-single</span>=<span class="literal">FALSE</span>  \</span><br><span class="line">    <span class="attribute">--keep-secondary</span>=<span class="literal">False</span>  \</span><br><span class="line">    <span class="attribute">--overwrite</span>=<span class="literal">True</span>  \</span><br><span class="line">    <span class="attribute">--max-num</span>=20000  \</span><br><span class="line">    <span class="attribute">--min-cov</span>=500  \</span><br><span class="line">    <span class="attribute">--verbose</span>=<span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<p>删除中间文件<br> remove temporary files <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">rm</span> <span class="selector-tag">atac_v1_adult_brain_fresh_5k</span><span class="selector-class">.snap</span><span class="selector-class">.snap</span><span class="selector-class">.bam</span> </span><br><span class="line"><span class="selector-tag">rm</span> <span class="selector-tag">atac_v1_adult_brain_fresh_5k_possorted</span><span class="selector-class">.header</span><span class="selector-class">.sam</span></span><br></pre></td></tr></table></figure></p>
<p>（2）use the <mark class="label default"><font color=c52950>fragment tsv file</font></mark>. Fragment file is already filtered, this will disable snaptools to generate quality control metrics. <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># decompress the gz file</span></span><br><span class="line">gunzip atac_v1_adult_brain_fresh_5k_fragments.tsv.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># sort the tsv file using the 4th column (barcode column)</span></span><br><span class="line">sort -k4,4 atac_v1_adult_brain_fresh_5k_fragments.tsv &gt; atac_v1_adult_brain_fresh_5k_fragments.bed</span><br><span class="line"></span><br><span class="line"><span class="comment"># compress the bed file </span></span><br><span class="line">gzip atac_v1_adult_brain_fresh_5k_fragments.bed</span><br><span class="line"></span><br><span class="line"><span class="comment"># run snap files using the bed file</span></span><br><span class="line">snaptools snap-pre  \</span><br><span class="line">    <span class="attribute">--input-file</span>=atac_v1_adult_brain_fresh_5k_fragments.bed.gz  \</span><br><span class="line">    <span class="attribute">--output-snap</span>=atac_v1_adult_brain_fresh_5k.snap  \</span><br><span class="line">    <span class="attribute">--genome-name</span>=mm10  \</span><br><span class="line">    <span class="attribute">--genome-size</span>=mm10.chrom.sizes  \</span><br><span class="line">    <span class="attribute">--min-mapq</span>=30  \</span><br><span class="line">    <span class="attribute">--min-flen</span>=50  \</span><br><span class="line">    <span class="attribute">--max-flen</span>=1000  \</span><br><span class="line">    <span class="attribute">--keep-chrm</span>=<span class="literal">TRUE</span>  \</span><br><span class="line">    <span class="attribute">--keep-single</span>=<span class="literal">FALSE</span>  \</span><br><span class="line">    <span class="attribute">--keep-secondary</span>=<span class="literal">False</span>  \</span><br><span class="line">    <span class="attribute">--overwrite</span>=<span class="literal">True</span>  \</span><br><span class="line">    <span class="attribute">--max-num</span>=20000  \</span><br><span class="line">    <span class="attribute">--min-cov</span>=500  \</span><br><span class="line">    <span class="attribute">--verbose</span>=<span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<h3 id="how-to-create-a-snap-file-from-bam-or-bed-file">5）How to create a snap file from bam or bed file?</h3>
<p>在很多情况下，我们可以直接使用snaptools pre子程序将比对好的、按read名称进行排序的bam或bed文件作为输入，生成snap格式文件。强烈建议使用未经过滤的比对文件作为输入。<br> （1）对于bam文件，我们需要在read的名称前添加细胞的barcode信息，如下所示： <figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">samtools view demo.bam|head</span><br><span class="line"></span><br><span class="line">AAACTACCAGAAAGACGCAGTT:<span class="number">7001113</span>:<span class="number">968</span>:HMYT2BCX2:<span class="number">1</span>:<span class="number">1215</span>:<span class="number">20520</span>:<span class="number">88475</span>    <span class="number">77</span>  *   <span class="number">0</span>   <span class="number">0</span>   *   *   <span class="number">0</span>   <span class="number">0</span>CTATGAGCACCGTCTCCGCCTCAGATGTGTATAAGAGACAGCAGAGTAAC @DDBAI??E?<span class="number">1</span>/&lt;<span class="symbol">DCGECEHEHHGG1@</span><span class="symbol">GEHIIIHGGDGE@</span>HIHEEIIHH1  AS:i:<span class="number">0</span>  XS:i:<span class="number">0</span></span><br><span class="line">AAACTACCAGAAAGACGCAGTT:<span class="number">7001113</span>:<span class="number">968</span>:HMYT2BCX2:<span class="number">1</span>:<span class="number">1215</span>:<span class="number">20520</span>:<span class="number">88475</span>    <span class="number">141</span> *   <span class="number">0</span>   <span class="number">0</span>   *   *   <span class="number">0</span>   <span class="number">0</span>GGCTTGTACAGAGCAAGTGCTGAAGTCCCTTTCTGATGACGTTCAACAGC <span class="number">0</span>&lt;<span class="number">000</span>/&lt;&lt;<span class="number">1</span>&lt;D1CC111&lt;&lt;<span class="number">1</span>&lt;<span class="number">1</span>&lt;<span class="number">111</span>&lt;<span class="number">111</span>&lt;&lt;CDCF1&lt;<span class="number">1</span>&lt;DHH&lt;&lt;&lt;&lt;C11  AS:i:<span class="number">0</span>  XS:i:<span class="number">0</span></span><br><span class="line">AAACTACCAGAAAGACGCAGTT:<span class="number">7001113</span>:<span class="number">968</span>:HMYT2BCX2:<span class="number">1</span>:<span class="number">2201</span>:<span class="number">20009</span>:<span class="number">41468</span>    <span class="number">77</span>  *   <span class="number">0</span>   <span class="number">0</span>   *   *   <span class="number">0</span>   <span class="number">0</span>CGGTGCCCCTGTCCTGTTCGTGCCCACCGTCTCCGCCTCAGATGTGTATA <span class="symbol">DDD@</span>D/D&lt;DHIHEHCCF1&lt;&lt;CCCGH?GHI1C1DHIII0&lt;<span class="number">1</span>D1&lt;<span class="number">111</span>&lt;<span class="number">1</span>&lt;<span class="number">1</span>  AS:i:<span class="number">0</span>  XS:i:<span class="number">0</span></span><br><span class="line">AAACTACCAGAAAGACGCAGTT:<span class="number">7001113</span>:<span class="number">968</span>:HMYT2BCX2:<span class="number">1</span>:<span class="number">2201</span>:<span class="number">20009</span>:<span class="number">41468</span>    <span class="number">141</span> *   <span class="number">0</span>   <span class="number">0</span>   *   *   <span class="number">0</span>   <span class="number">0</span>GAGCGAGGGCGGCAGAGGCAGGGGGAGGAGACCCGGTGGCCCGGCAGGCT <span class="number">0</span>&lt;<span class="number">00</span>&lt;/&lt;<span class="comment">//&lt;//&lt;//111000/&lt;&lt;/&lt;/&lt;0&lt;1&lt;1&lt;//&lt;&lt;0&lt;DCC/&lt;///&lt;D  AS:i:0  XS:i:0</span></span><br><span class="line"></span><br><span class="line"># 使用snaptools将bam文件转换为snap格式文件</span><br><span class="line">snaptools snap-pre  \</span><br><span class="line">    --input-file=demo.bam  \</span><br><span class="line">    --output-snap=demo.snap  \</span><br><span class="line">    --genome-name=mm10  \</span><br><span class="line">    --genome-size=mm10.chrom.sizes  \</span><br><span class="line">    --min-mapq=<span class="number">30</span>  \</span><br><span class="line">    --min-flen=<span class="number">0</span>  \</span><br><span class="line">    --max-flen=<span class="number">1000</span>  \</span><br><span class="line">    --keep-chrm=TRUE  \</span><br><span class="line">    --keep-single=TRUE  \</span><br><span class="line">    --keep-secondary=False  \</span><br><span class="line">    --overwrite=True  \</span><br><span class="line">    --min-cov=<span class="number">100</span>  \</span><br><span class="line">    --verbose=True</span><br></pre></td></tr></table></figure></p>
<p>（2）对于bed格式的文件，应将barcode信息添加到第四列中，如下所示： <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">zcat demo.bed.gz | head</span><br><span class="line"></span><br><span class="line">chr2    74358918    74358981    AACGAGAGCTAAAGACGCAGTT</span><br><span class="line">chr6    134212048   134212100   AACGAGAGCTAAAGACGCAGTT</span><br><span class="line">chr10    93276785    93276892    AACGAGAGCTAAAGACGCAGTT</span><br><span class="line">chr2    128601366   128601634   AACGAGAGCTAAAGCGCATGCT</span><br><span class="line">chr16    62129428    62129661    AACGAGAGCTAACAACCTTCTG</span><br><span class="line">chr8    84946184    84946369    AACGAGAGCTAACAACCTTCTG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用snaptools将bed文件转换为snap格式文件</span></span><br><span class="line">snaptools snap-pre  \</span><br><span class="line">    <span class="attribute">--input-file</span>=demo.bed.gz  \</span><br><span class="line">    <span class="attribute">--output-snap</span>=demo.snap  \</span><br><span class="line">    <span class="attribute">--genome-name</span>=mm10  \</span><br><span class="line">    <span class="attribute">--genome-size</span>=mm10.chrom.sizes  \</span><br><span class="line">    <span class="attribute">--min-mapq</span>=30  \</span><br><span class="line">    <span class="attribute">--min-flen</span>=0  \</span><br><span class="line">    <span class="attribute">--max-flen</span>=1000  \</span><br><span class="line">    <span class="attribute">--keep-chrm</span>=<span class="literal">TRUE</span>  \</span><br><span class="line">    <span class="attribute">--keep-single</span>=<span class="literal">TRUE</span>  \</span><br><span class="line">    <span class="attribute">--keep-secondary</span>=<span class="literal">False</span>  \</span><br><span class="line">    <span class="attribute">--overwrite</span>=<span class="literal">True</span>  \</span><br><span class="line">    <span class="attribute">--min-cov</span>=100  \</span><br><span class="line">    <span class="attribute">--verbose</span>=<span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<h3 id="how-to-group-reads">6）How to group reads?</h3>
<p>（1）Group reads from one cell ATACAGCCTCGC in snap file sample1.snap. <figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">library(SnapATAC);</span><br><span class="line"><span class="attr">snap_files</span> = <span class="string">"sample1.snap"</span>;</span><br><span class="line"><span class="attr">barcode_sel</span> = <span class="string">"ATACAGCCTCGC"</span>;</span><br><span class="line">reads.<span class="attr">gr</span> = extractReads(barcode_sel, snap_files);</span><br></pre></td></tr></table></figure></p>
<p>（2）Group reads from multiple barcodes in one snap file. <figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">library(SnapATAC);</span><br><span class="line"><span class="attr">barcode_sel</span> = c(<span class="string">"ATACAGCCTCGC"</span>, <span class="string">"ATACAGCCTCGG"</span>)</span><br><span class="line"><span class="attr">snap_files</span> = rep(<span class="string">"sample1.snap"</span>, <span class="number">2</span>);</span><br><span class="line">reads.<span class="attr">gr</span> = extractReads(barcode_sel, snap_files);</span><br></pre></td></tr></table></figure></p>
<p>（3）Group reads from multiple barcodes and multiple snap files. <figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">library(SnapATAC);</span><br><span class="line"><span class="attr">barcode_sel</span> = rep(<span class="string">"ATACAGCCTCGC"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="attr">snap_files</span> = c(<span class="string">"sample1.snap"</span>, <span class="string">"sample2.snap"</span>);</span><br><span class="line">reads.<span class="attr">gr</span> = extractReads(barcode_sel, snap_files);</span><br></pre></td></tr></table></figure></p>
<h3 id="how-to-analyze-multiple-samples-together">7）How to analyze multiple samples together?</h3>
<p>因为SnapATAC软件使用cell-by-bin矩阵对细胞进行聚类分群，这使他很容易将多个样本进行结合并执行比较分析。它需要将所有的样本创建相同bin size大小的cell-by-bin矩阵。在这里，我们以PBMC_5K和PBMC_10K数据为例进行分析。 <figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ R</span><br><span class="line"><span class="comment"># 加载SnapATAC包</span></span><br><span class="line">library(SnapATAC);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载示例数据</span></span><br><span class="line">system(<span class="string">"wget http://renlab.sdsc.edu/r3fang/share/Fang_2019/published_scATAC/atac_v1_pbmc_10k_fastqs/atac_v1_pbmc_10k.snap"</span>);</span><br><span class="line">system(<span class="string">"wget http://renlab.sdsc.edu/r3fang/share/Fang_2019/published_scATAC/atac_v1_pbmc_5k_fastqs/atac_v1_pbmc_5k.snap"</span>);</span><br><span class="line"><span class="built_in">file</span>.<span class="built_in">list</span> = c(<span class="string">"atac_v1_pbmc_5k.snap"</span>, <span class="string">"atac_v1_pbmc_10k.snap"</span>);</span><br><span class="line">sample.<span class="built_in">list</span> = c(<span class="string">"pbmc.5k"</span>, <span class="string">"pbmc.10k"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用createSnap函数将两个数据结合在一起</span></span><br><span class="line">x.sp = createSnap(<span class="built_in">file</span>=<span class="built_in">file</span>.<span class="built_in">list</span>, sample=sample.<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure></p>
<mark class="label default"><font color=c52950>createSnap</font></mark>
<p>函数将创建一个snap对象，该对象中包含了每个snap文件的名称和相应的barcodes信息。</p>
<h3 id="how-to-choose-bin-size">8）How to choose bin size?</h3>
<p>SnapATAC软件是基于cell-by-bin矩阵对细胞进行聚类分群的，因此选择不同的bin size可能对细胞的聚类分群产生较大的影响。如何选择最优的bin size，这个问题没有绝对的答案。</p>
<p>一方面，我们发现在5kb-50kb范围内的bin size大小的改变，并没有明显地改变细胞聚类分群的结果(如下图所示)。而另一方面，我们确实注意到了一个大的bin size通常会生成相对较少的cluster。这种聚类的差异，可以使用分辨率较小的Louvain聚类算法进行弥补。</p>
<p>使用较大bin size的好处是可以节省一些内存，这对于一些大型数据集尤为有用。这里提供了一个bin size大小选择的主观建议。</p>
<table>
<thead>
<tr class="header">
<th>#of cell</th>
<th>bin size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0-50k</td>
<td>5kb</td>
</tr>
<tr class="even">
<td>50k-100k</td>
<td>10kb</td>
</tr>
<tr class="odd">
<td>100k-1M</td>
<td>20kb-50kb</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>scRNA</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>R</tag>
        <tag>scRNA</tag>
        <tag>ATAC</tag>
      </tags>
  </entry>
</search>
